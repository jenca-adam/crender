#include "crender.h"
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// TODO: size_t can overflow!!
// FIXME

cr_Object cr_Object_new(void) {
  cr_REQUIRE_INIT cr_Object object = {0};
  object.vertices = (cr_Vec3_dynarr){0};
  object.uvs = (cr_Vec3_dynarr){0};
  object.normals = (cr_Vec3_dynarr){0};
  object.faces = (cr_Face_dynarr){0};
  object.valid = true;
  return object;
}
void cr_Object_add_vertex(cr_Object *object, cr_Vec3 vertex) {
  cr_DYNARR_PUSH(&object->vertices, vertex);
}
void cr_Object_add_uv(cr_Object *object, cr_Vec3 uv) {
  cr_DYNARR_PUSH(&object->uvs, uv);
}
void cr_Object_add_normal(cr_Object *object, cr_Vec3 normal) {
  cr_DYNARR_PUSH(&object->normals, normal);
}
void cr_Object_add_face(cr_Object *object, cr_Face face) {
  cr_DYNARR_PUSH(&object->faces, face);
}

void cr_Object_compute_vertex_tangents(cr_Object *object,
                                       cr_Vec3 *out_tangents) {
  for (size_t i = 0; i < object->faces.count; i++) {
    cr_Face face = object->faces.items[i];
    cr_Triangle vs, uvs;
    if (!cr_Face_gettri(&face, object, VERTEX, &vs))
      continue;
    if (!cr_Face_gettri(&face, object, UV, &uvs))
      continue;
    cr_Vec3 tri_tangent = cr_Triangle_get_tangent(vs, uvs);
    for (int j = 0; j < 3; j++) {
      size_t vi = face.vs[j] - 1;
      cr_Vec3_ADD_INPLACE(out_tangents[vi], tri_tangent);
    }
  }
  for (size_t i = 0; i < object->vertices.count; i++) {
    if (cr_Vec3_length(out_tangents[i]) > 0)
      out_tangents[i] = cr_Vec3_normalized(out_tangents[i]);
  }
}

void cr_Object_compute_smooth_normals(cr_Object *object, cr_Vec3 *out_normals) {
  for (size_t i = 0; i < object->faces.count; i++) {
    cr_Face face = object->faces.items[i];
    cr_Triangle vs;
    if (!cr_Face_gettri(&face, object, VERTEX, &vs))
      continue;
    cr_Vec3 tri_normal =
        cr_Vec3_mul(cr_Triangle_get_normal(vs), cr_Triangle_get_area(vs));
    for (int j = 0; j < 3; j++) {
      size_t vi = face.vs[j] - 1;
      cr_Vec3_ADD_INPLACE(out_normals[vi], tri_normal);
    }
  }
  for (size_t i = 0; i < object->vertices.count; i++) {
    if (cr_Vec3_length(out_normals[i]) > 0)
      out_normals[i] = cr_Vec3_normalized(out_normals[i]);
  }
}

void cr_Object_compute_flat_normals(cr_Object *object, cr_Vec3 *out_normals) {
  for (size_t i = 0; i < object->faces.count; i++) {
    cr_Face face = object->faces.items[i];
    cr_Triangle vs;
    if (!cr_Face_gettri(&face, object, VERTEX, &vs))
      continue;
    cr_Vec3 tri_normal = cr_Triangle_get_normal(vs);
    out_normals[i] = tri_normal;
  }
}
bool read_vec3(FILE *fp, cr_Vec3 *v) {
  char buffer[1024];
  cr_num x = 0;
  cr_num y = 0;
  cr_num z = 0;
  if (fgets(buffer, sizeof(buffer), fp)) {
    sscanf(buffer, cr_NUM_FMT " " cr_NUM_FMT " " cr_NUM_FMT, &x, &y, &z);
    *v = cr_Vec3_create(x, y, z);
    return true;
  }
  return false;
}

void read_face_vinfo(const char *vinfo, size_t *vindex, size_t *uvindex,
                     size_t *nindex) {
  const char *p = vinfo;
  char *end;

  *vindex = strtoul(p, &end, 10);
  if (end == p)
    return;
  p = end;

  if (*p == '/') {
    p++;

    if (*p != '/') {
      *uvindex = strtoul(p, &end, 10);
      if (end == p)
        return;
      p = end;
    }

    if (*p == '/') {
      p++;

      *nindex = strtoul(p, &end, 10);
      if (end == p)
        return;
    }
  }
}

bool read_face(FILE *fp, cr_Object *obj, cr_Face *face) {

  char vinfos[3][512];
  char buffer[2048];
  if (fgets(buffer, sizeof(buffer), fp)) {
    if (sscanf(buffer, "%s %s %s", vinfos[0], vinfos[1], vinfos[2]) != 3) {
      return false;
    }
  }
  *face = (cr_Face){0};
  for (int i = 0; i < 3; i++) {
    face->vs[i] = 0;
    face->vts[i] = 0;
    face->vns[i] = 0;
    read_face_vinfo(vinfos[i], &face->vs[i], &face->vts[i], &face->vns[i]);
    if (face->vs[i] > obj->vertices.count) {
      cr_ERROR("corrupted object file! vertex index %zu out of bounds for a "
               "model with %zu vertices",
               face->vs[i], obj->vertices.count);
    }
    if (face->vts[i] > obj->uvs.count) {
      cr_ERROR("Corrupted object file! UV index %zu out of bounds for a model "
               "with %zu UVs",
               face->vts[i], obj->uvs.count);
      if (face->vns[i] > obj->normals.count) {
        cr_ERROR("Corrupted object file! Vertex normal index %zu out of bounds "
                 "for a model with %zu vertex normals",
                 face->vns[i], obj->normals.count);
      }
    }
  }
  return true;
}
bool cr_Object_writeOBJ(cr_Object *object, char *fn) {
  if (!object->valid) {
    return false;
  }
  FILE *fp = fopen(fn, "wb");
  if (!fp) {
    fprintf(stderr, "cr_Object_writeOBJ: fopen(%s) failed: %s", fn,
            strerror(errno));
    return false;
  }
  fprintf(fp, "# generated by crender\n");
  fprintf(fp, "o Object\n");
  for (size_t i = 0; i < object->vertices.count; i++) {
    cr_Vec3 vertex = object->vertices.items[i];
    fprintf(fp, "v " cr_NUM_FMT " " cr_NUM_FMT " " cr_NUM_FMT "\n", vertex.x,
            vertex.y, vertex.z);
  }
  fprintf(fp, "# %zu vertices\n", object->vertices.count);
  for (size_t i = 0; i < object->uvs.count; i++) {
    cr_Vec3 uv = object->uvs.items[i];
    fprintf(fp, "vt " cr_NUM_FMT " " cr_NUM_FMT " " cr_NUM_FMT "\n", uv.x, uv.y,
            uv.z);
  }
  fprintf(fp, "# %zu texture vertices\n", object->uvs.count);

  for (size_t i = 0; i < object->normals.count; i++) {
    cr_Vec3 normal = object->normals.items[i];
    fprintf(fp, "vn " cr_NUM_FMT " " cr_NUM_FMT " " cr_NUM_FMT "\n", normal.x,
            normal.y, normal.z);
  }
  fprintf(fp, "# %zu vertex normals\n", object->normals.count);
  for (size_t i = 0; i < object->faces.count; i++) {
    cr_Face f = object->faces.items[i];
    fprintf(fp, "f %zu/%zu/%zu %zu/%zu/%zu %zu/%zu/%zu\n", f.vs[0], f.vts[0],
            f.vns[0], f.vs[1], f.vts[1], f.vns[1], f.vs[2], f.vts[2], f.vns[2]);
  }
  fprintf(fp, "# %zu faces\n", object->faces.count);
  fclose(fp);
  return true;
}
cr_Object cr_Object_readOBJ(char *fn, cr_NormalPrecompMode precompute_mode) {

  FILE *fp = fopen(fn, "rb");

  if (!fp) {
    fprintf(stderr, "cr_Object_fromOBJ: fopen(%s) failed: %s\n", fn,
            strerror(errno));
    return (cr_Object){0};
  }
  cr_Object object = cr_Object_new();
  cr_Vec3 arg;
  char line_type[64];
  while (1) {
    if (fscanf(fp, "%s ", line_type) != 1) {
      break;
    }
    if (!strcmp(line_type, "v")) {
      if (!read_vec3(fp, &arg)) {
        break;
      }
      cr_Object_add_vertex(&object, arg);
    } else if (!strcmp(line_type, "vt")) {
      if (!read_vec3(fp, &arg)) {
        break;
      }
      cr_Object_add_uv(&object, arg);
    } else if (!strcmp(line_type, "vn") && precompute_mode == NONE) {
      if (!read_vec3(fp, &arg)) {
        break;
      }
      cr_Object_add_normal(&object, arg);
    } else if (!strcmp(line_type, "f")) {
      cr_Face farg;
      if (!read_face(fp, &object, &farg)) {
        break;
      }
      cr_Object_add_face(&object, farg);
    }
  }
  if (!object.vertices.count) {
    fprintf(stderr, "cr_Object_fromOBJ: no vertices defined in object file %s",
            fn);
    cr_Object_dealloc(&object);
    return (cr_Object){0};
  }
  if (!object.uvs.count) {
    fprintf(stderr, "cr_Object_fromOBJ: object %s is not uv-mapped!", fn);
    cr_Object_dealloc(&object);
    return (cr_Object){0};
  }
  if (!object.normals.count && precompute_mode == NONE) {
    precompute_mode = FLAT;
  }
  switch (precompute_mode) {
  case SMOOTH:
    cr_DYNARR_DEALLOC(object.normals);
    cr_Vec3 *smooth_ns = calloc(object.vertices.count, sizeof(*smooth_ns));
    cr_Object_compute_smooth_normals(&object, smooth_ns);
    cr_DYNARR_FROMARR(&object.normals, smooth_ns, object.vertices.count);
    free(smooth_ns);
    // we need to update faces to point to new normals
    for (size_t i = 0; i < object.faces.count; i++) {
      cr_Face *f = &object.faces.items[i];
      f->vns[0] = f->vs[0];
      f->vns[1] = f->vs[1];
      f->vns[2] = f->vs[2];
    }
    break;
  case FLAT:
    cr_DYNARR_DEALLOC(object.normals);
    cr_Vec3 *flat_ns = calloc(object.faces.count, sizeof(*flat_ns));
    cr_Object_compute_flat_normals(&object, flat_ns);
    cr_DYNARR_FROMARR(&object.normals, flat_ns, object.faces.count);
    free(flat_ns);
    for (size_t i = 0; i < object.faces.count; i++) {
      cr_Face *f = &object.faces.items[i];
      f->vns[0] = i + 1;
      f->vns[1] = i + 1;
      f->vns[2] = i + 1;
    }
    break;
  default:
    break;
  }
  fclose(fp);
  return object;
}

bool cr_Face_gettri(cr_Face *face, cr_Object *obj, cr_FaceTriType tt,
                    cr_Triangle *tri) {
  switch (tt) {
  case VERTEX:
    if (!obj->vertices.count) {
      return false;
    }
    *tri = cr_Triangle_create(obj->vertices.items[face->vs[0] - 1],
                              obj->vertices.items[face->vs[1] - 1],
                              obj->vertices.items[face->vs[2] - 1]);
    break;

  case UV:
    if (!obj->uvs.count) {
      return false;
    }

    *tri = cr_Triangle_create(obj->uvs.items[face->vts[0] - 1],
                              obj->uvs.items[face->vts[1] - 1],
                              obj->uvs.items[face->vts[2] - 1]);
    break;
  case NORMAL:
    if (!obj->normals.count) {
      return false;
    }
    *tri = cr_Triangle_create(obj->normals.items[face->vns[0] - 1],
                              obj->normals.items[face->vns[1] - 1],
                              obj->normals.items[face->vns[2] - 1]);
    break;
  default:
    cr_UNREACHABLE("face_gettri");
  }
  return true;
}
void cr_Object_dealloc(cr_Object *object) {
  if (!object || !object->valid)
    return;
  cr_DYNARR_DEALLOC(object->vertices);
  cr_DYNARR_DEALLOC(object->uvs);
  cr_DYNARR_DEALLOC(object->normals);
  cr_DYNARR_DEALLOC(object->faces);
}

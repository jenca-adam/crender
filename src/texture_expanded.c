#define __STDC__ 1
#define __STDC_VERSION__ 202311L
#define __STDC_UTF_16__ 1
#define __STDC_UTF_32__ 1
#define __STDC_HOSTED__ 1
#define __STDC_EMBED_NOT_FOUND__ 0
#define __STDC_EMBED_FOUND__ 1
#define __STDC_EMBED_EMPTY__ 2
#define __GNUC__ 15
#define __GNUC_MINOR__ 2
#define __GNUC_PATCHLEVEL__ 1
#define __VERSION__ "15.2.1 20251112"
#define __ATOMIC_RELAXED 0
#define __ATOMIC_SEQ_CST 5
#define __ATOMIC_ACQUIRE 2
#define __ATOMIC_RELEASE 3
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_CONSUME 1
#define __pic__ 2
#define __PIC__ 2
#define __pie__ 2
#define __PIE__ 2
#define __FINITE_MATH_ONLY__ 0
#define _LP64 1
#define __LP64__ 1
#define __SIZEOF_INT__ 4
#define __SIZEOF_LONG__ 8
#define __SIZEOF_LONG_LONG__ 8
#define __SIZEOF_SHORT__ 2
#define __SIZEOF_FLOAT__ 4
#define __SIZEOF_DOUBLE__ 8
#define __SIZEOF_LONG_DOUBLE__ 16
#define __SIZEOF_SIZE_T__ 8
#define __CHAR_BIT__ 8
#define __BIGGEST_ALIGNMENT__ 16
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __ORDER_BIG_ENDIAN__ 4321
#define __ORDER_PDP_ENDIAN__ 3412
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __SIZEOF_POINTER__ 8
#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
#define __SIZE_TYPE__ long unsigned int
#define __PTRDIFF_TYPE__ long int
#define __WCHAR_TYPE__ int
#define __WINT_TYPE__ unsigned int
#define __INTMAX_TYPE__ long int
#define __UINTMAX_TYPE__ long unsigned int
#define __CHAR8_TYPE__ unsigned char
#define __CHAR16_TYPE__ short unsigned int
#define __CHAR32_TYPE__ unsigned int
#define __SIG_ATOMIC_TYPE__ int
#define __INT8_TYPE__ signed char
#define __INT16_TYPE__ short int
#define __INT32_TYPE__ int
#define __INT64_TYPE__ long int
#define __UINT8_TYPE__ unsigned char
#define __UINT16_TYPE__ short unsigned int
#define __UINT32_TYPE__ unsigned int
#define __UINT64_TYPE__ long unsigned int
#define __INT_LEAST8_TYPE__ signed char
#define __INT_LEAST16_TYPE__ short int
#define __INT_LEAST32_TYPE__ int
#define __INT_LEAST64_TYPE__ long int
#define __UINT_LEAST8_TYPE__ unsigned char
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __UINT_LEAST32_TYPE__ unsigned int
#define __UINT_LEAST64_TYPE__ long unsigned int
#define __INT_FAST8_TYPE__ signed char
#define __INT_FAST16_TYPE__ long int
#define __INT_FAST32_TYPE__ long int
#define __INT_FAST64_TYPE__ long int
#define __UINT_FAST8_TYPE__ unsigned char
#define __UINT_FAST16_TYPE__ long unsigned int
#define __UINT_FAST32_TYPE__ long unsigned int
#define __UINT_FAST64_TYPE__ long unsigned int
#define __INTPTR_TYPE__ long int
#define __UINTPTR_TYPE__ long unsigned int
#define __GXX_ABI_VERSION 1020
#define __SCHAR_MAX__ 0x7f
#define __SHRT_MAX__ 0x7fff
#define __INT_MAX__ 0x7fffffff
#define __LONG_MAX__ 0x7fffffffffffffffL
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
#define __WCHAR_MAX__ 0x7fffffff
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
#define __WINT_MAX__ 0xffffffffU
#define __WINT_MIN__ 0U
#define __PTRDIFF_MAX__ 0x7fffffffffffffffL
#define __SIZE_MAX__ 0xffffffffffffffffUL
#define __SCHAR_WIDTH__ 8
#define __SHRT_WIDTH__ 16
#define __INT_WIDTH__ 32
#define __LONG_WIDTH__ 64
#define __LONG_LONG_WIDTH__ 64
#define __WCHAR_WIDTH__ 32
#define __WINT_WIDTH__ 32
#define __PTRDIFF_WIDTH__ 64
#define __SIZE_WIDTH__ 64
#define __BITINT_MAXWIDTH__ 65535
#define __INTMAX_MAX__ 0x7fffffffffffffffL
#define __INTMAX_C(c) c##L
#define __UINTMAX_MAX__ 0xffffffffffffffffUL
#define __UINTMAX_C(c) c##UL
#define __INTMAX_WIDTH__ 64
#define __SIG_ATOMIC_MAX__ 0x7fffffff
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __SIG_ATOMIC_WIDTH__ 32
#define __INT8_MAX__ 0x7f
#define __INT16_MAX__ 0x7fff
#define __INT32_MAX__ 0x7fffffff
#define __INT64_MAX__ 0x7fffffffffffffffL
#define __UINT8_MAX__ 0xff
#define __UINT16_MAX__ 0xffff
#define __UINT32_MAX__ 0xffffffffU
#define __UINT64_MAX__ 0xffffffffffffffffUL
#define __INT_LEAST8_MAX__ 0x7f
#define __INT8_C(c) c
#define __INT_LEAST8_WIDTH__ 8
#define __INT_LEAST16_MAX__ 0x7fff
#define __INT16_C(c) c
#define __INT_LEAST16_WIDTH__ 16
#define __INT_LEAST32_MAX__ 0x7fffffff
#define __INT32_C(c) c
#define __INT_LEAST32_WIDTH__ 32
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffL
#define __INT64_C(c) c##L
#define __INT_LEAST64_WIDTH__ 64
#define __UINT_LEAST8_MAX__ 0xff
#define __UINT8_C(c) c
#define __UINT_LEAST16_MAX__ 0xffff
#define __UINT16_C(c) c
#define __UINT_LEAST32_MAX__ 0xffffffffU
#define __UINT32_C(c) c##U
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL
#define __UINT64_C(c) c##UL
#define __INT_FAST8_MAX__ 0x7f
#define __INT_FAST8_WIDTH__ 8
#define __INT_FAST16_MAX__ 0x7fffffffffffffffL
#define __INT_FAST16_WIDTH__ 64
#define __INT_FAST32_MAX__ 0x7fffffffffffffffL
#define __INT_FAST32_WIDTH__ 64
#define __INT_FAST64_MAX__ 0x7fffffffffffffffL
#define __INT_FAST64_WIDTH__ 64
#define __UINT_FAST8_MAX__ 0xff
#define __UINT_FAST16_MAX__ 0xffffffffffffffffUL
#define __UINT_FAST32_MAX__ 0xffffffffffffffffUL
#define __UINT_FAST64_MAX__ 0xffffffffffffffffUL
#define __INTPTR_MAX__ 0x7fffffffffffffffL
#define __INTPTR_WIDTH__ 64
#define __UINTPTR_MAX__ 0xffffffffffffffffUL
#define __GCC_IEC_559 2
#define __GCC_IEC_559_COMPLEX 2
#define __FLT_EVAL_METHOD__ 0
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
#define __DEC_EVAL_METHOD__ 2
#define __FLT_RADIX__ 2
#define __FLT_MANT_DIG__ 24
#define __FLT_DIG__ 6
#define __FLT_MIN_EXP__ (-125)
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MAX_EXP__ 128
#define __FLT_MAX_10_EXP__ 38
#define __FLT_DECIMAL_DIG__ 9
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
#define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
#define __FLT_HAS_DENORM__ 1
#define __FLT_HAS_INFINITY__ 1
#define __FLT_HAS_QUIET_NAN__ 1
#define __FLT_IS_IEC_60559__ 1
#define __DBL_MANT_DIG__ 53
#define __DBL_DIG__ 15
#define __DBL_MIN_EXP__ (-1021)
#define __DBL_MIN_10_EXP__ (-307)
#define __DBL_MAX_EXP__ 1024
#define __DBL_MAX_10_EXP__ 308
#define __DBL_DECIMAL_DIG__ 17
#define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
#define __DBL_NORM_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
#define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)
#define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)
#define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)
#define __DBL_HAS_DENORM__ 1
#define __DBL_HAS_INFINITY__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __DBL_IS_IEC_60559__ 1
#define __LDBL_MANT_DIG__ 64
#define __LDBL_DIG__ 18
#define __LDBL_MIN_EXP__ (-16381)
#define __LDBL_MIN_10_EXP__ (-4931)
#define __LDBL_MAX_EXP__ 16384
#define __LDBL_MAX_10_EXP__ 4932
#define __DECIMAL_DIG__ 21
#define __LDBL_DECIMAL_DIG__ 21
#define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L
#define __LDBL_NORM_MAX__ 1.18973149535723176502126385303097021e+4932L
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
#define __LDBL_HAS_DENORM__ 1
#define __LDBL_HAS_INFINITY__ 1
#define __LDBL_HAS_QUIET_NAN__ 1
#define __LDBL_IS_IEC_60559__ 1
#define __FLT16_MANT_DIG__ 11
#define __FLT16_DIG__ 3
#define __FLT16_MIN_EXP__ (-13)
#define __FLT16_MIN_10_EXP__ (-4)
#define __FLT16_MAX_EXP__ 16
#define __FLT16_MAX_10_EXP__ 4
#define __FLT16_DECIMAL_DIG__ 5
#define __FLT16_MAX__ 6.55040000000000000000000000000000000e+4F16
#define __FLT16_NORM_MAX__ 6.55040000000000000000000000000000000e+4F16
#define __FLT16_MIN__ 6.10351562500000000000000000000000000e-5F16
#define __FLT16_EPSILON__ 9.76562500000000000000000000000000000e-4F16
#define __FLT16_DENORM_MIN__ 5.96046447753906250000000000000000000e-8F16
#define __FLT16_HAS_DENORM__ 1
#define __FLT16_HAS_INFINITY__ 1
#define __FLT16_HAS_QUIET_NAN__ 1
#define __FLT16_IS_IEC_60559__ 1
#define __FLT32_MANT_DIG__ 24
#define __FLT32_DIG__ 6
#define __FLT32_MIN_EXP__ (-125)
#define __FLT32_MIN_10_EXP__ (-37)
#define __FLT32_MAX_EXP__ 128
#define __FLT32_MAX_10_EXP__ 38
#define __FLT32_DECIMAL_DIG__ 9
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
#define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
#define __FLT32_HAS_DENORM__ 1
#define __FLT32_HAS_INFINITY__ 1
#define __FLT32_HAS_QUIET_NAN__ 1
#define __FLT32_IS_IEC_60559__ 1
#define __FLT64_MANT_DIG__ 53
#define __FLT64_DIG__ 15
#define __FLT64_MIN_EXP__ (-1021)
#define __FLT64_MIN_10_EXP__ (-307)
#define __FLT64_MAX_EXP__ 1024
#define __FLT64_MAX_10_EXP__ 308
#define __FLT64_DECIMAL_DIG__ 17
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
#define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
#define __FLT64_HAS_DENORM__ 1
#define __FLT64_HAS_INFINITY__ 1
#define __FLT64_HAS_QUIET_NAN__ 1
#define __FLT64_IS_IEC_60559__ 1
#define __FLT128_MANT_DIG__ 113
#define __FLT128_DIG__ 33
#define __FLT128_MIN_EXP__ (-16381)
#define __FLT128_MIN_10_EXP__ (-4931)
#define __FLT128_MAX_EXP__ 16384
#define __FLT128_MAX_10_EXP__ 4932
#define __FLT128_DECIMAL_DIG__ 36
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
#define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
#define __FLT128_HAS_DENORM__ 1
#define __FLT128_HAS_INFINITY__ 1
#define __FLT128_HAS_QUIET_NAN__ 1
#define __FLT128_IS_IEC_60559__ 1
#define __FLT32X_MANT_DIG__ 53
#define __FLT32X_DIG__ 15
#define __FLT32X_MIN_EXP__ (-1021)
#define __FLT32X_MIN_10_EXP__ (-307)
#define __FLT32X_MAX_EXP__ 1024
#define __FLT32X_MAX_10_EXP__ 308
#define __FLT32X_DECIMAL_DIG__ 17
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
#define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
#define __FLT32X_HAS_DENORM__ 1
#define __FLT32X_HAS_INFINITY__ 1
#define __FLT32X_HAS_QUIET_NAN__ 1
#define __FLT32X_IS_IEC_60559__ 1
#define __FLT64X_MANT_DIG__ 64
#define __FLT64X_DIG__ 18
#define __FLT64X_MIN_EXP__ (-16381)
#define __FLT64X_MIN_10_EXP__ (-4931)
#define __FLT64X_MAX_EXP__ 16384
#define __FLT64X_MAX_10_EXP__ 4932
#define __FLT64X_DECIMAL_DIG__ 21
#define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x
#define __FLT64X_NORM_MAX__ 1.18973149535723176502126385303097021e+4932F64x
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
#define __FLT64X_HAS_DENORM__ 1
#define __FLT64X_HAS_INFINITY__ 1
#define __FLT64X_HAS_QUIET_NAN__ 1
#define __FLT64X_IS_IEC_60559__ 1
#define __BFLT16_MANT_DIG__ 8
#define __BFLT16_DIG__ 2
#define __BFLT16_MIN_EXP__ (-125)
#define __BFLT16_MIN_10_EXP__ (-37)
#define __BFLT16_MAX_EXP__ 128
#define __BFLT16_MAX_10_EXP__ 38
#define __BFLT16_DECIMAL_DIG__ 4
#define __BFLT16_MAX__ 3.38953138925153547590470800371487867e+38BF16
#define __BFLT16_NORM_MAX__ 3.38953138925153547590470800371487867e+38BF16
#define __BFLT16_MIN__ 1.17549435082228750796873653722224568e-38BF16
#define __BFLT16_EPSILON__ 7.81250000000000000000000000000000000e-3BF16
#define __BFLT16_DENORM_MIN__ 9.18354961579912115600575419704879436e-41BF16
#define __BFLT16_HAS_DENORM__ 1
#define __BFLT16_HAS_INFINITY__ 1
#define __BFLT16_HAS_QUIET_NAN__ 1
#define __BFLT16_IS_IEC_60559__ 0
#define __DEC32_MANT_DIG__ 7
#define __DEC32_MIN_EXP__ (-94)
#define __DEC32_MAX_EXP__ 97
#define __DEC32_MIN__ 1E-95DF
#define __DEC32_MAX__ 9.999999E96DF
#define __DEC32_EPSILON__ 1E-6DF
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __DEC64_MANT_DIG__ 16
#define __DEC64_MIN_EXP__ (-382)
#define __DEC64_MAX_EXP__ 385
#define __DEC64_MIN__ 1E-383DD
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __DEC64_EPSILON__ 1E-15DD
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX_EXP__ 6145
#define __DEC128_MIN__ 1E-6143DL
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __DEC128_EPSILON__ 1E-33DL
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __DEC64X_MANT_DIG__ 34
#define __DEC64X_MIN_EXP__ (-6142)
#define __DEC64X_MAX_EXP__ 6145
#define __DEC64X_MIN__ 1E-6143D64x
#define __DEC64X_MAX__ 9.999999999999999999999999999999999E6144D64x
#define __DEC64X_EPSILON__ 1E-33D64x
#define __DEC64X_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143D64x
#define __REGISTER_PREFIX__
#define __USER_LABEL_PREFIX__
#define __GNUC_STDC_INLINE__ 1
#define __NO_INLINE__ 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR8_T_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
#define __GCC_ATOMIC_INT_LOCK_FREE 2
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
#define __GCC_ATOMIC_LLONG_LOCK_FREE 2
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
#define __GCC_DESTRUCTIVE_SIZE 64
#define __GCC_CONSTRUCTIVE_SIZE 64
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
#define __HAVE_SPECULATION_SAFE_VALUE 1
#define __GCC_HAVE_DWARF2_CFI_ASM 1
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SSP_STRONG__ 3
#define __SIZEOF_INT128__ 16
#define __SIZEOF_WCHAR_T__ 4
#define __SIZEOF_WINT_T__ 4
#define __SIZEOF_PTRDIFF_T__ 8
#define __amd64 1
#define __amd64__ 1
#define __x86_64 1
#define __x86_64__ 1
#define __SIZEOF_FLOAT80__ 16
#define __SIZEOF_FLOAT128__ 16
#define __ATOMIC_HLE_ACQUIRE 65536
#define __ATOMIC_HLE_RELEASE 131072
#define __GCC_ASM_FLAG_OUTPUTS__ 1
#define __k8 1
#define __k8__ 1
#define __code_model_small__ 1
#define __MMX__ 1
#define __SSE__ 1
#define __SSE2__ 1
#define __FXSR__ 1
#define __SSE_MATH__ 1
#define __SSE2_MATH__ 1
#define __MMX_WITH_SSE__ 1
#define __SEG_FS 1
#define __SEG_GS 1
#define __gnu_linux__ 1
#define __linux 1
#define __linux__ 1
#define linux 1
#define __unix 1
#define __unix__ 1
#define unix 1
#define __ELF__ 1
#define __DECIMAL_BID_FORMAT__ 1
#define _STDC_PREDEF_H 1
#define __STDC_IEC_559__ 1
#define __STDC_IEC_60559_BFP__ 201404L
#define __STDC_IEC_559_COMPLEX__ 1
#define __STDC_IEC_60559_COMPLEX__ 201404L
#define __STDC_ISO_10646__ 201706L
#define _CRENDER_H
#define _CRENDER_CFG_H
#define CR_CFG_NO_BFCULL 1
#define _MATH_H 1
#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#undef __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#define _FEATURES_H 1
#undef __USE_ISOC11
#undef __USE_ISOC99
#undef __USE_ISOC95
#undef __USE_ISOCXX11
#undef __USE_POSIX
#undef __USE_POSIX2
#undef __USE_POSIX199309
#undef __USE_POSIX199506
#undef __USE_XOPEN
#undef __USE_XOPEN_EXTENDED
#undef __USE_UNIX98
#undef __USE_XOPEN2K
#undef __USE_XOPEN2KXSI
#undef __USE_XOPEN2K8
#undef __USE_XOPEN2K8XSI
#undef __USE_LARGEFILE
#undef __USE_LARGEFILE64
#undef __USE_FILE_OFFSET64
#undef __USE_MISC
#undef __USE_ATFILE
#undef __USE_DYNAMIC_STACK_SIZE
#undef __USE_GNU
#undef __USE_FORTIFY_LEVEL
#undef __KERNEL_STRICT_NAMES
#undef __GLIBC_USE_ISOC23
#undef __GLIBC_USE_ISOC2Y
#undef __GLIBC_USE_DEPRECATED_GETS
#undef __GLIBC_USE_DEPRECATED_SCANF
#undef __GLIBC_USE_C23_STRTOL
#define __KERNEL_STRICT_NAMES
#define __GNUC_PREREQ(maj, min)                                                \
  ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
#define __glibc_clang_prereq(maj, min) 0
#define __GLIBC_USE(F) __GLIBC_USE_##F
#undef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE 1
#define __GLIBC_USE_ISOC2Y 0
#define __GLIBC_USE_ISOC23 1
#define __USE_ISOC11 1
#define __USE_ISOC99 1
#define __USE_ISOC95 1
#define __USE_POSIX_IMPLICITLY 1
#undef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#undef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
#define __USE_POSIX 1
#define __USE_POSIX2 1
#define __USE_POSIX199309 1
#define __USE_POSIX199506 1
#define __USE_XOPEN2K 1
#undef __USE_ISOC95
#define __USE_ISOC95 1
#undef __USE_ISOC99
#define __USE_ISOC99 1
#define __USE_XOPEN2K8 1
#undef _ATFILE_SOURCE
#define _ATFILE_SOURCE 1
#define __WORDSIZE 64
#define __WORDSIZE_TIME64_COMPAT32 1
#define __SYSCALL_WORDSIZE 64
#define __WORDSIZE 64
#define __WORDSIZE_TIME64_COMPAT32 1
#define __SYSCALL_WORDSIZE 64
#define __TIMESIZE __WORDSIZE
#define __USE_TIME_BITS64 1
#define __USE_MISC 1
#define __USE_ATFILE 1
#define __USE_FORTIFY_LEVEL 0
#define __GLIBC_USE_DEPRECATED_GETS 0
#define __GLIBC_USE_DEPRECATED_SCANF 0
#define __GLIBC_USE_C23_STRTOL 1
#undef __GNU_LIBRARY__
#define __GNU_LIBRARY__ 6
#define __GLIBC__ 2
#define __GLIBC_MINOR__ 42
#define __GLIBC_PREREQ(maj, min)                                               \
  ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))
#define _SYS_CDEFS_H 1
#undef __P
#undef __PMT
#define __glibc_has_attribute(attr) __has_attribute(attr)
#define __glibc_has_builtin(name) __has_builtin(name)
#define __glibc_has_extension(ext) __has_extension(ext)
#define __LEAF , __leaf__
#define __LEAF_ATTR __attribute__((__leaf__))
#define __THROW __attribute__((__nothrow__ __LEAF))
#define __THROWNL __attribute__((__nothrow__))
#define __NTH(fct) __attribute__((__nothrow__ __LEAF)) fct
#define __NTHNL(fct) __attribute__((__nothrow__)) fct
#define __COLD __attribute__((__cold__))
#define __P(args) args
#define __PMT(args) args
#define __CONCAT(x, y) x##y
#define __STRING(x) #x
#define __ptr_t void *
#define __BEGIN_DECLS
#define __END_DECLS
#define __attribute_overloadable__
#define __bos(ptr) __builtin_object_size(ptr, __USE_FORTIFY_LEVEL > 1)
#define __bos0(ptr) __builtin_object_size(ptr, 0)
#define __glibc_objsize0(__o) __bos0(__o)
#define __glibc_objsize(__o) __bos(__o)
#define __warnattr(msg) __attribute__((__warning__(msg)))
#define __errordecl(name, msg)                                                 \
  extern void name(void) __attribute__((__error__(msg)))
#define __flexarr []
#define __glibc_c99_flexarr_available 1
#define __REDIRECT(name, proto, alias) name proto __asm__(__ASMNAME(#alias))
#define __REDIRECT_NTH(name, proto, alias)                                     \
  name proto __asm__(__ASMNAME(#alias)) __THROW
#define __REDIRECT_NTHNL(name, proto, alias)                                   \
  name proto __asm__(__ASMNAME(#alias)) __THROWNL
#define __ASMNAME(cname) __ASMNAME2(__USER_LABEL_PREFIX__, cname)
#define __ASMNAME2(prefix, cname) __STRING(prefix) cname
#define __REDIRECT_FORTIFY __REDIRECT
#define __REDIRECT_FORTIFY_NTH __REDIRECT_NTH
#define __attribute_malloc__ __attribute__((__malloc__))
#define __attribute_alloc_size__(params) __attribute__((__alloc_size__ params))
#define __attribute_alloc_align__(param) __attribute__((__alloc_align__ param))
#define __attribute_pure__ __attribute__((__pure__))
#define __attribute_const__ __attribute__((__const__))
#define __attribute_maybe_unused__ __attribute__((__unused__))
#define __attribute_used__ __attribute__((__used__))
#define __attribute_noinline__ __attribute__((__noinline__))
#define __attribute_deprecated__ __attribute__((__deprecated__))
#define __attribute_deprecated_msg__(msg) __attribute__((__deprecated__(msg)))
#define __attribute_format_arg__(x) __attribute__((__format_arg__(x)))
#define __attribute_format_strfmon__(a, b)                                     \
  __attribute__((__format__(__strfmon__, a, b)))
#define __attribute_nonnull__(params) __attribute__((__nonnull__ params))
#define __nonnull(params) __attribute_nonnull__(params)
#define __returns_nonnull __attribute__((__returns_nonnull__))
#define __attribute_warn_unused_result__ __attribute__((__warn_unused_result__))
#define __wur
#undef __always_inline
#define __always_inline __inline __attribute__((__always_inline__))
#define __attribute_artificial__ __attribute__((__artificial__))
#define __extern_inline extern __inline __attribute__((__gnu_inline__))
#define __extern_always_inline                                                 \
  extern __always_inline __attribute__((__gnu_inline__))
#define __fortify_function __extern_always_inline __attribute_artificial__
#define __va_arg_pack() __builtin_va_arg_pack()
#define __va_arg_pack_len() __builtin_va_arg_pack_len()
#define __restrict_arr __restrict
#define __glibc_unlikely(cond) __builtin_expect((cond), 0)
#define __glibc_likely(cond) __builtin_expect((cond), 1)
#define __attribute_nonstring__ __attribute__((__nonstring__))
#undef __attribute_copy__
#define __attribute_copy__(arg) __attribute__((__copy__(arg)))
#define __WORDSIZE 64
#define __WORDSIZE_TIME64_COMPAT32 1
#define __SYSCALL_WORDSIZE 64
#define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
#define __LDBL_REDIR1(name, proto, alias) name proto
#define __LDBL_REDIR(name, proto) name proto
#define __LDBL_REDIR1_NTH(name, proto, alias) name proto __THROW
#define __LDBL_REDIR_NTH(name, proto) name proto __THROW
#define __LDBL_REDIR2_DECL(name)
#define __LDBL_REDIR_DECL(name)
#define __REDIRECT_LDBL(name, proto, alias) __REDIRECT(name, proto, alias)
#define __REDIRECT_NTH_LDBL(name, proto, alias)                                \
  __REDIRECT_NTH(name, proto, alias)
#define __glibc_macro_warning1(message) _Pragma(#message)
#define __glibc_macro_warning(message)                                         \
  __glibc_macro_warning1(GCC warning message)
#define __HAVE_GENERIC_SELECTION 1
#define __attr_access(x) __attribute__((__access__ x))
#define __fortified_attr_access(a, o, s) __attr_access((a, o, s))
#define __attr_access_none(argno) __attribute__((__access__(__none__, argno)))
#define __attr_dealloc(dealloc, argno)                                         \
  __attribute__((__malloc__(dealloc, argno)))
#define __attr_dealloc_free __attr_dealloc(__builtin_free, 1)
#define __attribute_returns_twice__ __attribute__((__returns_twice__))
#define __attribute_struct_may_alias__ __attribute__((__may_alias__))
#define __stub___compat_bdflush
#define __stub_chflags
#define __stub_fchflags
#define __stub_gtty
#define __stub_revoke
#define __stub_setlogin
#define __stub_sigreturn
#define __stub_stty
#undef __GLIBC_USE_LIB_EXT2
#define __GLIBC_USE_LIB_EXT2 0
#undef __GLIBC_USE_IEC_60559_BFP_EXT
#define __GLIBC_USE_IEC_60559_BFP_EXT 0
#undef __GLIBC_USE_IEC_60559_BFP_EXT_C23
#define __GLIBC_USE_IEC_60559_BFP_EXT_C23 1
#undef __GLIBC_USE_IEC_60559_EXT
#define __GLIBC_USE_IEC_60559_EXT 0
#undef __GLIBC_USE_IEC_60559_FUNCS_EXT
#define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
#undef __GLIBC_USE_IEC_60559_FUNCS_EXT_C23
#define __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 1
#undef __GLIBC_USE_IEC_60559_TYPES_EXT
#define __GLIBC_USE_IEC_60559_TYPES_EXT 0

#define _BITS_TYPES_H 1
#define __WORDSIZE 64
#define __WORDSIZE_TIME64_COMPAT32 1
#define __SYSCALL_WORDSIZE 64
#define __WORDSIZE 64
#define __WORDSIZE_TIME64_COMPAT32 1
#define __SYSCALL_WORDSIZE 64
#define __TIMESIZE __WORDSIZE
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
#define __S16_TYPE short int
#define __U16_TYPE unsigned short int
#define __S32_TYPE int
#define __U32_TYPE unsigned int
#define __SLONGWORD_TYPE long int
#define __ULONGWORD_TYPE unsigned long int
#define __SQUAD_TYPE long int
#define __UQUAD_TYPE unsigned long int
#define __SWORD_TYPE long int
#define __UWORD_TYPE unsigned long int
#define __SLONG32_TYPE int
#define __ULONG32_TYPE unsigned int
#define __S64_TYPE long int
#define __U64_TYPE unsigned long int
#define __STD_TYPE typedef
#define _BITS_TYPESIZES_H 1
#define __SYSCALL_SLONG_TYPE __SLONGWORD_TYPE
#define __SYSCALL_ULONG_TYPE __ULONGWORD_TYPE
#define __DEV_T_TYPE __UQUAD_TYPE
#define __UID_T_TYPE __U32_TYPE
#define __GID_T_TYPE __U32_TYPE
#define __INO_T_TYPE __SYSCALL_ULONG_TYPE
#define __INO64_T_TYPE __UQUAD_TYPE
#define __MODE_T_TYPE __U32_TYPE
#define __NLINK_T_TYPE __SYSCALL_ULONG_TYPE
#define __FSWORD_T_TYPE __SYSCALL_SLONG_TYPE
#define __OFF_T_TYPE __SYSCALL_SLONG_TYPE
#define __OFF64_T_TYPE __SQUAD_TYPE
#define __PID_T_TYPE __S32_TYPE
#define __RLIM_T_TYPE __SYSCALL_ULONG_TYPE
#define __RLIM64_T_TYPE __UQUAD_TYPE
#define __BLKCNT_T_TYPE __SYSCALL_SLONG_TYPE
#define __BLKCNT64_T_TYPE __SQUAD_TYPE
#define __FSBLKCNT_T_TYPE __SYSCALL_ULONG_TYPE
#define __FSBLKCNT64_T_TYPE __UQUAD_TYPE
#define __FSFILCNT_T_TYPE __SYSCALL_ULONG_TYPE
#define __FSFILCNT64_T_TYPE __UQUAD_TYPE
#define __ID_T_TYPE __U32_TYPE
#define __CLOCK_T_TYPE __SYSCALL_SLONG_TYPE
#define __TIME_T_TYPE __SYSCALL_SLONG_TYPE
#define __USECONDS_T_TYPE __U32_TYPE
#define __SUSECONDS_T_TYPE __SYSCALL_SLONG_TYPE
#define __SUSECONDS64_T_TYPE __SQUAD_TYPE
#define __DADDR_T_TYPE __S32_TYPE
#define __KEY_T_TYPE __S32_TYPE
#define __CLOCKID_T_TYPE __S32_TYPE
#define __TIMER_T_TYPE void *
#define __BLKSIZE_T_TYPE __SYSCALL_SLONG_TYPE
#define __FSID_T_TYPE                                                          \
  struct {                                                                     \
    int __val[2];                                                              \
  }
#define __SSIZE_T_TYPE __SWORD_TYPE
#define __CPU_MASK_TYPE __SYSCALL_ULONG_TYPE
#define __OFF_T_MATCHES_OFF64_T 1
#define __INO_T_MATCHES_INO64_T 1
#define __RLIM_T_MATCHES_RLIM64_T 1
#define __STATFS_MATCHES_STATFS64 1
#define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
#define __FD_SETSIZE 1024
#define _BITS_TIME64_H 1
#define __TIME64_T_TYPE __TIME_T_TYPE
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct {
  int __val[2];
} __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
#undef __STD_TYPE
#define _BITS_LIBM_SIMD_DECL_STUBS_H 1
#define __DECL_SIMD_cos
#define __DECL_SIMD_cosf
#define __DECL_SIMD_cosl
#define __DECL_SIMD_cosf16
#define __DECL_SIMD_cosf32
#define __DECL_SIMD_cosf64
#define __DECL_SIMD_cosf128
#define __DECL_SIMD_cosf32x
#define __DECL_SIMD_cosf64x
#define __DECL_SIMD_cosf128x
#define __DECL_SIMD_sin
#define __DECL_SIMD_sinf
#define __DECL_SIMD_sinl
#define __DECL_SIMD_sinf16
#define __DECL_SIMD_sinf32
#define __DECL_SIMD_sinf64
#define __DECL_SIMD_sinf128
#define __DECL_SIMD_sinf32x
#define __DECL_SIMD_sinf64x
#define __DECL_SIMD_sinf128x
#define __DECL_SIMD_sincos
#define __DECL_SIMD_sincosf
#define __DECL_SIMD_sincosl
#define __DECL_SIMD_sincosf16
#define __DECL_SIMD_sincosf32
#define __DECL_SIMD_sincosf64
#define __DECL_SIMD_sincosf128
#define __DECL_SIMD_sincosf32x
#define __DECL_SIMD_sincosf64x
#define __DECL_SIMD_sincosf128x
#define __DECL_SIMD_log
#define __DECL_SIMD_logf
#define __DECL_SIMD_logl
#define __DECL_SIMD_logf16
#define __DECL_SIMD_logf32
#define __DECL_SIMD_logf64
#define __DECL_SIMD_logf128
#define __DECL_SIMD_logf32x
#define __DECL_SIMD_logf64x
#define __DECL_SIMD_logf128x
#define __DECL_SIMD_exp
#define __DECL_SIMD_expf
#define __DECL_SIMD_expl
#define __DECL_SIMD_expf16
#define __DECL_SIMD_expf32
#define __DECL_SIMD_expf64
#define __DECL_SIMD_expf128
#define __DECL_SIMD_expf32x
#define __DECL_SIMD_expf64x
#define __DECL_SIMD_expf128x
#define __DECL_SIMD_pow
#define __DECL_SIMD_powf
#define __DECL_SIMD_powl
#define __DECL_SIMD_powf16
#define __DECL_SIMD_powf32
#define __DECL_SIMD_powf64
#define __DECL_SIMD_powf128
#define __DECL_SIMD_powf32x
#define __DECL_SIMD_powf64x
#define __DECL_SIMD_powf128x
#define __DECL_SIMD_acos
#define __DECL_SIMD_acosf
#define __DECL_SIMD_acosl
#define __DECL_SIMD_acosf16
#define __DECL_SIMD_acosf32
#define __DECL_SIMD_acosf64
#define __DECL_SIMD_acosf128
#define __DECL_SIMD_acosf32x
#define __DECL_SIMD_acosf64x
#define __DECL_SIMD_acosf128x
#define __DECL_SIMD_atan
#define __DECL_SIMD_atanf
#define __DECL_SIMD_atanl
#define __DECL_SIMD_atanf16
#define __DECL_SIMD_atanf32
#define __DECL_SIMD_atanf64
#define __DECL_SIMD_atanf128
#define __DECL_SIMD_atanf32x
#define __DECL_SIMD_atanf64x
#define __DECL_SIMD_atanf128x
#define __DECL_SIMD_asin
#define __DECL_SIMD_asinf
#define __DECL_SIMD_asinl
#define __DECL_SIMD_asinf16
#define __DECL_SIMD_asinf32
#define __DECL_SIMD_asinf64
#define __DECL_SIMD_asinf128
#define __DECL_SIMD_asinf32x
#define __DECL_SIMD_asinf64x
#define __DECL_SIMD_asinf128x
#define __DECL_SIMD_hypot
#define __DECL_SIMD_hypotf
#define __DECL_SIMD_hypotl
#define __DECL_SIMD_hypotf16
#define __DECL_SIMD_hypotf32
#define __DECL_SIMD_hypotf64
#define __DECL_SIMD_hypotf128
#define __DECL_SIMD_hypotf32x
#define __DECL_SIMD_hypotf64x
#define __DECL_SIMD_hypotf128x
#define __DECL_SIMD_exp2
#define __DECL_SIMD_exp2f
#define __DECL_SIMD_exp2l
#define __DECL_SIMD_exp2f16
#define __DECL_SIMD_exp2f32
#define __DECL_SIMD_exp2f64
#define __DECL_SIMD_exp2f128
#define __DECL_SIMD_exp2f32x
#define __DECL_SIMD_exp2f64x
#define __DECL_SIMD_exp2f128x
#define __DECL_SIMD_exp10
#define __DECL_SIMD_exp10f
#define __DECL_SIMD_exp10l
#define __DECL_SIMD_exp10f16
#define __DECL_SIMD_exp10f32
#define __DECL_SIMD_exp10f64
#define __DECL_SIMD_exp10f128
#define __DECL_SIMD_exp10f32x
#define __DECL_SIMD_exp10f64x
#define __DECL_SIMD_exp10f128x
#define __DECL_SIMD_cosh
#define __DECL_SIMD_coshf
#define __DECL_SIMD_coshl
#define __DECL_SIMD_coshf16
#define __DECL_SIMD_coshf32
#define __DECL_SIMD_coshf64
#define __DECL_SIMD_coshf128
#define __DECL_SIMD_coshf32x
#define __DECL_SIMD_coshf64x
#define __DECL_SIMD_coshf128x
#define __DECL_SIMD_expm1
#define __DECL_SIMD_expm1f
#define __DECL_SIMD_expm1l
#define __DECL_SIMD_expm1f16
#define __DECL_SIMD_expm1f32
#define __DECL_SIMD_expm1f64
#define __DECL_SIMD_expm1f128
#define __DECL_SIMD_expm1f32x
#define __DECL_SIMD_expm1f64x
#define __DECL_SIMD_expm1f128x
#define __DECL_SIMD_sinh
#define __DECL_SIMD_sinhf
#define __DECL_SIMD_sinhl
#define __DECL_SIMD_sinhf16
#define __DECL_SIMD_sinhf32
#define __DECL_SIMD_sinhf64
#define __DECL_SIMD_sinhf128
#define __DECL_SIMD_sinhf32x
#define __DECL_SIMD_sinhf64x
#define __DECL_SIMD_sinhf128x
#define __DECL_SIMD_cbrt
#define __DECL_SIMD_cbrtf
#define __DECL_SIMD_cbrtl
#define __DECL_SIMD_cbrtf16
#define __DECL_SIMD_cbrtf32
#define __DECL_SIMD_cbrtf64
#define __DECL_SIMD_cbrtf128
#define __DECL_SIMD_cbrtf32x
#define __DECL_SIMD_cbrtf64x
#define __DECL_SIMD_cbrtf128x
#define __DECL_SIMD_atan2
#define __DECL_SIMD_atan2f
#define __DECL_SIMD_atan2l
#define __DECL_SIMD_atan2f16
#define __DECL_SIMD_atan2f32
#define __DECL_SIMD_atan2f64
#define __DECL_SIMD_atan2f128
#define __DECL_SIMD_atan2f32x
#define __DECL_SIMD_atan2f64x
#define __DECL_SIMD_atan2f128x
#define __DECL_SIMD_log10
#define __DECL_SIMD_log10f
#define __DECL_SIMD_log10l
#define __DECL_SIMD_log10f16
#define __DECL_SIMD_log10f32
#define __DECL_SIMD_log10f64
#define __DECL_SIMD_log10f128
#define __DECL_SIMD_log10f32x
#define __DECL_SIMD_log10f64x
#define __DECL_SIMD_log10f128x
#define __DECL_SIMD_log2
#define __DECL_SIMD_log2f
#define __DECL_SIMD_log2l
#define __DECL_SIMD_log2f16
#define __DECL_SIMD_log2f32
#define __DECL_SIMD_log2f64
#define __DECL_SIMD_log2f128
#define __DECL_SIMD_log2f32x
#define __DECL_SIMD_log2f64x
#define __DECL_SIMD_log2f128x
#define __DECL_SIMD_log1p
#define __DECL_SIMD_log1pf
#define __DECL_SIMD_log1pl
#define __DECL_SIMD_log1pf16
#define __DECL_SIMD_log1pf32
#define __DECL_SIMD_log1pf64
#define __DECL_SIMD_log1pf128
#define __DECL_SIMD_log1pf32x
#define __DECL_SIMD_log1pf64x
#define __DECL_SIMD_log1pf128x
#define __DECL_SIMD_logp1
#define __DECL_SIMD_logp1f
#define __DECL_SIMD_logp1l
#define __DECL_SIMD_logp1f16
#define __DECL_SIMD_logp1f32
#define __DECL_SIMD_logp1f64
#define __DECL_SIMD_logp1f128
#define __DECL_SIMD_logp1f32x
#define __DECL_SIMD_logp1f64x
#define __DECL_SIMD_logp1f128x
#define __DECL_SIMD_atanh
#define __DECL_SIMD_atanhf
#define __DECL_SIMD_atanhl
#define __DECL_SIMD_atanhf16
#define __DECL_SIMD_atanhf32
#define __DECL_SIMD_atanhf64
#define __DECL_SIMD_atanhf128
#define __DECL_SIMD_atanhf32x
#define __DECL_SIMD_atanhf64x
#define __DECL_SIMD_atanhf128x
#define __DECL_SIMD_acosh
#define __DECL_SIMD_acoshf
#define __DECL_SIMD_acoshl
#define __DECL_SIMD_acoshf16
#define __DECL_SIMD_acoshf32
#define __DECL_SIMD_acoshf64
#define __DECL_SIMD_acoshf128
#define __DECL_SIMD_acoshf32x
#define __DECL_SIMD_acoshf64x
#define __DECL_SIMD_acoshf128x
#define __DECL_SIMD_erf
#define __DECL_SIMD_erff
#define __DECL_SIMD_erfl
#define __DECL_SIMD_erff16
#define __DECL_SIMD_erff32
#define __DECL_SIMD_erff64
#define __DECL_SIMD_erff128
#define __DECL_SIMD_erff32x
#define __DECL_SIMD_erff64x
#define __DECL_SIMD_erff128x
#define __DECL_SIMD_tanh
#define __DECL_SIMD_tanhf
#define __DECL_SIMD_tanhl
#define __DECL_SIMD_tanhf16
#define __DECL_SIMD_tanhf32
#define __DECL_SIMD_tanhf64
#define __DECL_SIMD_tanhf128
#define __DECL_SIMD_tanhf32x
#define __DECL_SIMD_tanhf64x
#define __DECL_SIMD_tanhf128x
#define __DECL_SIMD_asinh
#define __DECL_SIMD_asinhf
#define __DECL_SIMD_asinhl
#define __DECL_SIMD_asinhf16
#define __DECL_SIMD_asinhf32
#define __DECL_SIMD_asinhf64
#define __DECL_SIMD_asinhf128
#define __DECL_SIMD_asinhf32x
#define __DECL_SIMD_asinhf64x
#define __DECL_SIMD_asinhf128x
#define __DECL_SIMD_erfc
#define __DECL_SIMD_erfcf
#define __DECL_SIMD_erfcl
#define __DECL_SIMD_erfcf16
#define __DECL_SIMD_erfcf32
#define __DECL_SIMD_erfcf64
#define __DECL_SIMD_erfcf128
#define __DECL_SIMD_erfcf32x
#define __DECL_SIMD_erfcf64x
#define __DECL_SIMD_erfcf128x
#define __DECL_SIMD_tan
#define __DECL_SIMD_tanf
#define __DECL_SIMD_tanl
#define __DECL_SIMD_tanf16
#define __DECL_SIMD_tanf32
#define __DECL_SIMD_tanf64
#define __DECL_SIMD_tanf128
#define __DECL_SIMD_tanf32x
#define __DECL_SIMD_tanf64x
#define __DECL_SIMD_tanf128x
#define __DECL_SIMD_sinpi
#define __DECL_SIMD_sinpif
#define __DECL_SIMD_sinpil
#define __DECL_SIMD_sinpif16
#define __DECL_SIMD_sinpif32
#define __DECL_SIMD_sinpif64
#define __DECL_SIMD_sinpif128
#define __DECL_SIMD_sinpif32x
#define __DECL_SIMD_sinpif64x
#define __DECL_SIMD_sinpif128x
#define __DECL_SIMD_cospi
#define __DECL_SIMD_cospif
#define __DECL_SIMD_cospil
#define __DECL_SIMD_cospif16
#define __DECL_SIMD_cospif32
#define __DECL_SIMD_cospif64
#define __DECL_SIMD_cospif128
#define __DECL_SIMD_cospif32x
#define __DECL_SIMD_cospif64x
#define __DECL_SIMD_cospif128x
#define __DECL_SIMD_tanpi
#define __DECL_SIMD_tanpif
#define __DECL_SIMD_tanpil
#define __DECL_SIMD_tanpif16
#define __DECL_SIMD_tanpif32
#define __DECL_SIMD_tanpif64
#define __DECL_SIMD_tanpif128
#define __DECL_SIMD_tanpif32x
#define __DECL_SIMD_tanpif64x
#define __DECL_SIMD_tanpif128x
#define __DECL_SIMD_acospi
#define __DECL_SIMD_acospif
#define __DECL_SIMD_acospil
#define __DECL_SIMD_acospif16
#define __DECL_SIMD_acospif32
#define __DECL_SIMD_acospif64
#define __DECL_SIMD_acospif128
#define __DECL_SIMD_acospif32x
#define __DECL_SIMD_acospif64x
#define __DECL_SIMD_acospif128x
#define __DECL_SIMD_asinpi
#define __DECL_SIMD_asinpif
#define __DECL_SIMD_asinpil
#define __DECL_SIMD_asinpif16
#define __DECL_SIMD_asinpif32
#define __DECL_SIMD_asinpif64
#define __DECL_SIMD_asinpif128
#define __DECL_SIMD_asinpif32x
#define __DECL_SIMD_asinpif64x
#define __DECL_SIMD_asinpif128x
#define __DECL_SIMD_atanpi
#define __DECL_SIMD_atanpif
#define __DECL_SIMD_atanpil
#define __DECL_SIMD_atanpif16
#define __DECL_SIMD_atanpif32
#define __DECL_SIMD_atanpif64
#define __DECL_SIMD_atanpif128
#define __DECL_SIMD_atanpif32x
#define __DECL_SIMD_atanpif64x
#define __DECL_SIMD_atanpif128x
#define __DECL_SIMD_atan2pi
#define __DECL_SIMD_atan2pif
#define __DECL_SIMD_atan2pil
#define __DECL_SIMD_atan2pif16
#define __DECL_SIMD_atan2pif32
#define __DECL_SIMD_atan2pif64
#define __DECL_SIMD_atan2pif128
#define __DECL_SIMD_atan2pif32x
#define __DECL_SIMD_atan2pif64x
#define __DECL_SIMD_atan2pif128x
#define _BITS_FLOATN_H
#define __HAVE_FLOAT128 1
#define __HAVE_DISTINCT_FLOAT128 1
#define __HAVE_FLOAT64X 1
#define __HAVE_FLOAT64X_LONG_DOUBLE 1
#define __f128(x) x##f128
#define __CFLOAT128 _Complex _Float128
#define _BITS_FLOATN_COMMON_H
#define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
#define __HAVE_FLOAT16 0
#define __HAVE_FLOAT32 1
#define __HAVE_FLOAT64 1
#define __HAVE_FLOAT32X 1
#define __HAVE_FLOAT128X 0
#define __HAVE_DISTINCT_FLOAT16 __HAVE_FLOAT16
#define __HAVE_DISTINCT_FLOAT32 0
#define __HAVE_DISTINCT_FLOAT64 0
#define __HAVE_DISTINCT_FLOAT32X 0
#define __HAVE_DISTINCT_FLOAT64X 0
#define __HAVE_DISTINCT_FLOAT128X __HAVE_FLOAT128X
#define __HAVE_FLOAT128_UNLIKE_LDBL                                            \
  (__HAVE_DISTINCT_FLOAT128 && __LDBL_MANT_DIG__ != 113)
#define __HAVE_FLOATN_NOT_TYPEDEF 1
#define __f32(x) x##f32
#define __f64(x) x##f64
#define __f32x(x) x##f32x
#define __f64x(x) x##f64x
#define __CFLOAT32 _Complex _Float32
#define __CFLOAT64 _Complex _Float64
#define __CFLOAT32X _Complex _Float32x
#define __CFLOAT64X _Complex _Float64x
#define HUGE_VAL (__builtin_huge_val())
#define HUGE_VALF (__builtin_huge_valf())
#define HUGE_VALL (__builtin_huge_vall())
#define INFINITY (__builtin_inff())
#define NAN (__builtin_nanf(""))
#define __GLIBC_FLT_EVAL_METHOD __FLT_EVAL_METHOD__
typedef float float_t;
typedef double double_t;
#define __FP_LOGB0_IS_MIN 1
#define __FP_LOGBNAN_IS_MIN 1
#define FP_ILOGB0 (-2147483647 - 1)
#define FP_ILOGBNAN (-2147483647 - 1)
#define __FP_LONG_MAX 0x7fffffffffffffffL
#define FP_LLOGB0 (-__FP_LONG_MAX - 1)
#define FP_LLOGBNAN (-__FP_LONG_MAX - 1)
enum {
  FP_INT_UPWARD =
#define FP_INT_UPWARD 0
      0,
  FP_INT_DOWNWARD =
#define FP_INT_DOWNWARD 1
      1,
  FP_INT_TOWARDZERO =
#define FP_INT_TOWARDZERO 2
      2,
  FP_INT_TONEARESTFROMZERO =
#define FP_INT_TONEARESTFROMZERO 3
      3,
  FP_INT_TONEAREST =
#define FP_INT_TONEAREST 4
      4,
};
#define __SIMD_DECL(function) __CONCAT(__DECL_SIMD_, function)
#define __MATHCALL_VEC(function, suffix, args)                                 \
  __SIMD_DECL(__MATH_PRECNAME(function, suffix))                               \
  __MATHCALL(function, suffix, args)
#define __MATHDECL_VEC(type, function, suffix, args)                           \
  __SIMD_DECL(__MATH_PRECNAME(function, suffix))                               \
  __MATHDECL(type, function, suffix, args)
#define __MATHCALL(function, suffix, args)                                     \
  __MATHDECL(_Mdouble_, function, suffix, args)
#define __MATHDECL(type, function, suffix, args)                               \
  __MATHDECL_1(type, function, suffix, args);                                  \
  __MATHDECL_1(type, __CONCAT(__, function), suffix, args)
#define __MATHCALLX(function, suffix, args, attrib)                            \
  __MATHDECLX(_Mdouble_, function, suffix, args, attrib)
#define __MATHDECLX(type, function, suffix, args, attrib)                      \
  __MATHDECL_1(type, function, suffix, args) __attribute__(attrib)
#define __MATHDECL_1_IMPL(type, function, suffix, args)                        \
  extern type __MATH_PRECNAME(function, suffix)                                \
  args __THROW
#define __MATHDECL_1(type, function, suffix, args)                             \
  __MATHDECL_1_IMPL(type, function, suffix, args)
#define __MATHDECL_ALIAS(type, function, suffix, args, alias)                  \
  __MATHDECL_1(type, function, suffix, args)
#define __MATHREDIR(type, function, suffix, args, to)                          \
  extern type __REDIRECT_NTH(__MATH_PRECNAME(function, suffix), args, to)
#define _Mdouble_ double
#define __MATH_PRECNAME(name, r) __CONCAT(name, r)
#define __MATH_DECLARING_DOUBLE 1
#define __MATH_DECLARING_FLOATN 0
extern int __fpclassify(double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __signbit(double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __isinf(double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __finite(double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __isnan(double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __iseqsig(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern int __issignaling(double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern double acos(double __x) __attribute__((__nothrow__, __leaf__));
extern double __acos(double __x) __attribute__((__nothrow__, __leaf__));
extern double asin(double __x) __attribute__((__nothrow__, __leaf__));
extern double __asin(double __x) __attribute__((__nothrow__, __leaf__));
extern double atan(double __x) __attribute__((__nothrow__, __leaf__));
extern double __atan(double __x) __attribute__((__nothrow__, __leaf__));
extern double atan2(double __y, double __x)
    __attribute__((__nothrow__, __leaf__));
extern double __atan2(double __y, double __x)
    __attribute__((__nothrow__, __leaf__));
extern double cos(double __x) __attribute__((__nothrow__, __leaf__));
extern double __cos(double __x) __attribute__((__nothrow__, __leaf__));
extern double sin(double __x) __attribute__((__nothrow__, __leaf__));
extern double __sin(double __x) __attribute__((__nothrow__, __leaf__));
extern double tan(double __x) __attribute__((__nothrow__, __leaf__));
extern double __tan(double __x) __attribute__((__nothrow__, __leaf__));
extern double acospi(double __x) __attribute__((__nothrow__, __leaf__));
extern double __acospi(double __x) __attribute__((__nothrow__, __leaf__));
extern double acospi(double __x) __attribute__((__nothrow__, __leaf__));
extern double __acospi(double __x) __attribute__((__nothrow__, __leaf__));
extern double asinpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double __asinpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double asinpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double __asinpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double atanpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double __atanpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double atanpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double __atanpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double atan2pi(double __y, double __x)
    __attribute__((__nothrow__, __leaf__));
extern double __atan2pi(double __y, double __x)
    __attribute__((__nothrow__, __leaf__));
extern double atan2pi(double __y, double __x)
    __attribute__((__nothrow__, __leaf__));
extern double __atan2pi(double __y, double __x)
    __attribute__((__nothrow__, __leaf__));
extern double cospi(double __x) __attribute__((__nothrow__, __leaf__));
extern double __cospi(double __x) __attribute__((__nothrow__, __leaf__));
extern double sinpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double __sinpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double tanpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double __tanpi(double __x) __attribute__((__nothrow__, __leaf__));
extern double cosh(double __x) __attribute__((__nothrow__, __leaf__));
extern double __cosh(double __x) __attribute__((__nothrow__, __leaf__));
extern double sinh(double __x) __attribute__((__nothrow__, __leaf__));
extern double __sinh(double __x) __attribute__((__nothrow__, __leaf__));
extern double tanh(double __x) __attribute__((__nothrow__, __leaf__));
extern double __tanh(double __x) __attribute__((__nothrow__, __leaf__));
extern double acosh(double __x) __attribute__((__nothrow__, __leaf__));
extern double __acosh(double __x) __attribute__((__nothrow__, __leaf__));
extern double asinh(double __x) __attribute__((__nothrow__, __leaf__));
extern double __asinh(double __x) __attribute__((__nothrow__, __leaf__));
extern double atanh(double __x) __attribute__((__nothrow__, __leaf__));
extern double __atanh(double __x) __attribute__((__nothrow__, __leaf__));
extern double exp(double __x) __attribute__((__nothrow__, __leaf__));
extern double __exp(double __x) __attribute__((__nothrow__, __leaf__));
extern double frexp(double __x, int *__exponent)
    __attribute__((__nothrow__, __leaf__));
extern double __frexp(double __x, int *__exponent)
    __attribute__((__nothrow__, __leaf__));
extern double ldexp(double __x, int __exponent)
    __attribute__((__nothrow__, __leaf__));
extern double __ldexp(double __x, int __exponent)
    __attribute__((__nothrow__, __leaf__));
extern double log(double __x) __attribute__((__nothrow__, __leaf__));
extern double __log(double __x) __attribute__((__nothrow__, __leaf__));
extern double log10(double __x) __attribute__((__nothrow__, __leaf__));
extern double __log10(double __x) __attribute__((__nothrow__, __leaf__));
extern double modf(double __x, double *__iptr)
    __attribute__((__nothrow__, __leaf__));
extern double __modf(double __x, double *__iptr)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2)));
extern double exp10(double __x) __attribute__((__nothrow__, __leaf__));
extern double __exp10(double __x) __attribute__((__nothrow__, __leaf__));
extern double exp2m1(double __x) __attribute__((__nothrow__, __leaf__));
extern double __exp2m1(double __x) __attribute__((__nothrow__, __leaf__));
extern double exp10m1(double __x) __attribute__((__nothrow__, __leaf__));
extern double __exp10m1(double __x) __attribute__((__nothrow__, __leaf__));
extern double log2p1(double __x) __attribute__((__nothrow__, __leaf__));
extern double __log2p1(double __x) __attribute__((__nothrow__, __leaf__));
extern double log10p1(double __x) __attribute__((__nothrow__, __leaf__));
extern double __log10p1(double __x) __attribute__((__nothrow__, __leaf__));
extern double logp1(double __x) __attribute__((__nothrow__, __leaf__));
extern double __logp1(double __x) __attribute__((__nothrow__, __leaf__));
extern double expm1(double __x) __attribute__((__nothrow__, __leaf__));
extern double __expm1(double __x) __attribute__((__nothrow__, __leaf__));
extern double log1p(double __x) __attribute__((__nothrow__, __leaf__));
extern double __log1p(double __x) __attribute__((__nothrow__, __leaf__));
extern double logb(double __x) __attribute__((__nothrow__, __leaf__));
extern double __logb(double __x) __attribute__((__nothrow__, __leaf__));
extern double exp2(double __x) __attribute__((__nothrow__, __leaf__));
extern double __exp2(double __x) __attribute__((__nothrow__, __leaf__));
extern double log2(double __x) __attribute__((__nothrow__, __leaf__));
extern double __log2(double __x) __attribute__((__nothrow__, __leaf__));
extern double pow(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double __pow(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double sqrt(double __x) __attribute__((__nothrow__, __leaf__));
extern double __sqrt(double __x) __attribute__((__nothrow__, __leaf__));
extern double hypot(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double __hypot(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double cbrt(double __x) __attribute__((__nothrow__, __leaf__));
extern double __cbrt(double __x) __attribute__((__nothrow__, __leaf__));
extern double compoundn(double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern double __compoundn(double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern double pown(double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern double __pown(double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern double powr(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double __powr(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double rootn(double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern double __rootn(double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern double rsqrt(double __x) __attribute__((__nothrow__, __leaf__));
extern double __rsqrt(double __x) __attribute__((__nothrow__, __leaf__));
extern double ceil(double __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern double fabs(double __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern double floor(double __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern double fmod(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double __fmod(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern int isinf(double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int finite(double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern double drem(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double __drem(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double significand(double __x) __attribute__((__nothrow__, __leaf__));
extern double __significand(double __x) __attribute__((__nothrow__, __leaf__));
extern double copysign(double __x, double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern double nan(const char *__tagb) __attribute__((__nothrow__, __leaf__));
extern double __nan(const char *__tagb) __attribute__((__nothrow__, __leaf__));
extern int isnan(double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern double j0(double) __attribute__((__nothrow__, __leaf__));
extern double __j0(double) __attribute__((__nothrow__, __leaf__));
extern double j1(double) __attribute__((__nothrow__, __leaf__));
extern double __j1(double) __attribute__((__nothrow__, __leaf__));
extern double jn(int, double) __attribute__((__nothrow__, __leaf__));
extern double __jn(int, double) __attribute__((__nothrow__, __leaf__));
extern double y0(double) __attribute__((__nothrow__, __leaf__));
extern double __y0(double) __attribute__((__nothrow__, __leaf__));
extern double y1(double) __attribute__((__nothrow__, __leaf__));
extern double __y1(double) __attribute__((__nothrow__, __leaf__));
extern double yn(int, double) __attribute__((__nothrow__, __leaf__));
extern double __yn(int, double) __attribute__((__nothrow__, __leaf__));
extern double erf(double) __attribute__((__nothrow__, __leaf__));
extern double __erf(double) __attribute__((__nothrow__, __leaf__));
extern double erfc(double) __attribute__((__nothrow__, __leaf__));
extern double __erfc(double) __attribute__((__nothrow__, __leaf__));
extern double lgamma(double) __attribute__((__nothrow__, __leaf__));
extern double __lgamma(double) __attribute__((__nothrow__, __leaf__));
extern double tgamma(double) __attribute__((__nothrow__, __leaf__));
extern double __tgamma(double) __attribute__((__nothrow__, __leaf__));
extern double gamma(double) __attribute__((__nothrow__, __leaf__));
extern double __gamma(double) __attribute__((__nothrow__, __leaf__));
extern double lgamma_r(double, int *__signgamp)
    __attribute__((__nothrow__, __leaf__));
extern double __lgamma_r(double, int *__signgamp)
    __attribute__((__nothrow__, __leaf__));
extern double rint(double __x) __attribute__((__nothrow__, __leaf__));
extern double __rint(double __x) __attribute__((__nothrow__, __leaf__));
extern double nextafter(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double __nextafter(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double nexttoward(double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern double __nexttoward(double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern double nextdown(double __x) __attribute__((__nothrow__, __leaf__));
extern double __nextdown(double __x) __attribute__((__nothrow__, __leaf__));
extern double nextup(double __x) __attribute__((__nothrow__, __leaf__));
extern double __nextup(double __x) __attribute__((__nothrow__, __leaf__));
extern double remainder(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double __remainder(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double scalbn(double __x, int __n)
    __attribute__((__nothrow__, __leaf__));
extern double __scalbn(double __x, int __n)
    __attribute__((__nothrow__, __leaf__));
extern int ilogb(double __x) __attribute__((__nothrow__, __leaf__));
extern int __ilogb(double __x) __attribute__((__nothrow__, __leaf__));
extern long int llogb(double __x) __attribute__((__nothrow__, __leaf__));
extern long int __llogb(double __x) __attribute__((__nothrow__, __leaf__));
extern double scalbln(double __x, long int __n)
    __attribute__((__nothrow__, __leaf__));
extern double __scalbln(double __x, long int __n)
    __attribute__((__nothrow__, __leaf__));
extern double nearbyint(double __x) __attribute__((__nothrow__, __leaf__));
extern double __nearbyint(double __x) __attribute__((__nothrow__, __leaf__));
extern double round(double __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern double trunc(double __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern double remquo(double __x, double __y, int *__quo)
    __attribute__((__nothrow__, __leaf__));
extern double __remquo(double __x, double __y, int *__quo)
    __attribute__((__nothrow__, __leaf__));
extern long int lrint(double __x) __attribute__((__nothrow__, __leaf__));
extern long int __lrint(double __x) __attribute__((__nothrow__, __leaf__));
__extension__ extern long long int llrint(double __x)
    __attribute__((__nothrow__, __leaf__));
extern long long int __llrint(double __x)
    __attribute__((__nothrow__, __leaf__));
extern long int lround(double __x) __attribute__((__nothrow__, __leaf__));
extern long int __lround(double __x) __attribute__((__nothrow__, __leaf__));
__extension__ extern long long int llround(double __x)
    __attribute__((__nothrow__, __leaf__));
extern long long int __llround(double __x)
    __attribute__((__nothrow__, __leaf__));
extern double fdim(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double __fdim(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern double fmax(double __x, double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern double fmin(double __x, double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern double fma(double __x, double __y, double __z)
    __attribute__((__nothrow__, __leaf__));
extern double __fma(double __x, double __y, double __z)
    __attribute__((__nothrow__, __leaf__));
extern double roundeven(double __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern __intmax_t fromfp(double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __intmax_t __fromfp(double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t ufromfp(double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t __ufromfp(double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __intmax_t fromfpx(double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __intmax_t __fromfpx(double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t ufromfpx(double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t __ufromfpx(double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern int canonicalize(double *__cx, const double *__x)
    __attribute__((__nothrow__, __leaf__));
extern double fmaximum(double __x, double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern double fminimum(double __x, double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern double fmaximum_num(double __x, double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern double fminimum_num(double __x, double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern double fmaximum_mag(double __x, double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern double fminimum_mag(double __x, double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern double fmaximum_mag_num(double __x, double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern double fminimum_mag_num(double __x, double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern double scalb(double __x, double __n)
    __attribute__((__nothrow__, __leaf__));
extern double __scalb(double __x, double __n)
    __attribute__((__nothrow__, __leaf__));
#undef _Mdouble_
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
#undef __MATH_DECLARING_FLOATN
#define _Mdouble_ float
#define __MATH_PRECNAME(name, r) name##f##r
#define __MATH_DECLARING_DOUBLE 0
#define __MATH_DECLARING_FLOATN 0
extern int __fpclassifyf(float __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __signbitf(float __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __isinff(float __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __finitef(float __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __isnanf(float __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __iseqsigf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern int __issignalingf(float __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern float acosf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __acosf(float __x) __attribute__((__nothrow__, __leaf__));
extern float asinf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __asinf(float __x) __attribute__((__nothrow__, __leaf__));
extern float atanf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __atanf(float __x) __attribute__((__nothrow__, __leaf__));
extern float atan2f(float __y, float __x)
    __attribute__((__nothrow__, __leaf__));
extern float __atan2f(float __y, float __x)
    __attribute__((__nothrow__, __leaf__));
extern float cosf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __cosf(float __x) __attribute__((__nothrow__, __leaf__));
extern float sinf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __sinf(float __x) __attribute__((__nothrow__, __leaf__));
extern float tanf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __tanf(float __x) __attribute__((__nothrow__, __leaf__));
extern float acospif(float __x) __attribute__((__nothrow__, __leaf__));
extern float __acospif(float __x) __attribute__((__nothrow__, __leaf__));
extern float acospif(float __x) __attribute__((__nothrow__, __leaf__));
extern float __acospif(float __x) __attribute__((__nothrow__, __leaf__));
extern float asinpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float __asinpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float asinpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float __asinpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float atanpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float __atanpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float atanpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float __atanpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float atan2pif(float __y, float __x)
    __attribute__((__nothrow__, __leaf__));
extern float __atan2pif(float __y, float __x)
    __attribute__((__nothrow__, __leaf__));
extern float atan2pif(float __y, float __x)
    __attribute__((__nothrow__, __leaf__));
extern float __atan2pif(float __y, float __x)
    __attribute__((__nothrow__, __leaf__));
extern float cospif(float __x) __attribute__((__nothrow__, __leaf__));
extern float __cospif(float __x) __attribute__((__nothrow__, __leaf__));
extern float sinpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float __sinpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float tanpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float __tanpif(float __x) __attribute__((__nothrow__, __leaf__));
extern float coshf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __coshf(float __x) __attribute__((__nothrow__, __leaf__));
extern float sinhf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __sinhf(float __x) __attribute__((__nothrow__, __leaf__));
extern float tanhf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __tanhf(float __x) __attribute__((__nothrow__, __leaf__));
extern float acoshf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __acoshf(float __x) __attribute__((__nothrow__, __leaf__));
extern float asinhf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __asinhf(float __x) __attribute__((__nothrow__, __leaf__));
extern float atanhf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __atanhf(float __x) __attribute__((__nothrow__, __leaf__));
extern float expf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __expf(float __x) __attribute__((__nothrow__, __leaf__));
extern float frexpf(float __x, int *__exponent)
    __attribute__((__nothrow__, __leaf__));
extern float __frexpf(float __x, int *__exponent)
    __attribute__((__nothrow__, __leaf__));
extern float ldexpf(float __x, int __exponent)
    __attribute__((__nothrow__, __leaf__));
extern float __ldexpf(float __x, int __exponent)
    __attribute__((__nothrow__, __leaf__));
extern float logf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __logf(float __x) __attribute__((__nothrow__, __leaf__));
extern float log10f(float __x) __attribute__((__nothrow__, __leaf__));
extern float __log10f(float __x) __attribute__((__nothrow__, __leaf__));
extern float modff(float __x, float *__iptr)
    __attribute__((__nothrow__, __leaf__));
extern float __modff(float __x, float *__iptr)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2)));
extern float exp10f(float __x) __attribute__((__nothrow__, __leaf__));
extern float __exp10f(float __x) __attribute__((__nothrow__, __leaf__));
extern float exp2m1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float __exp2m1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float exp10m1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float __exp10m1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float log2p1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float __log2p1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float log10p1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float __log10p1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float logp1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float __logp1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float expm1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float __expm1f(float __x) __attribute__((__nothrow__, __leaf__));
extern float log1pf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __log1pf(float __x) __attribute__((__nothrow__, __leaf__));
extern float logbf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __logbf(float __x) __attribute__((__nothrow__, __leaf__));
extern float exp2f(float __x) __attribute__((__nothrow__, __leaf__));
extern float __exp2f(float __x) __attribute__((__nothrow__, __leaf__));
extern float log2f(float __x) __attribute__((__nothrow__, __leaf__));
extern float __log2f(float __x) __attribute__((__nothrow__, __leaf__));
extern float powf(float __x, float __y) __attribute__((__nothrow__, __leaf__));
extern float __powf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern float sqrtf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __sqrtf(float __x) __attribute__((__nothrow__, __leaf__));
extern float hypotf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern float __hypotf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern float cbrtf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __cbrtf(float __x) __attribute__((__nothrow__, __leaf__));
extern float compoundnf(float __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern float __compoundnf(float __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern float pownf(float __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern float __pownf(float __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern float powrf(float __x, float __y) __attribute__((__nothrow__, __leaf__));
extern float __powrf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern float rootnf(float __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern float __rootnf(float __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern float rsqrtf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __rsqrtf(float __x) __attribute__((__nothrow__, __leaf__));
extern float ceilf(float __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern float fabsf(float __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern float floorf(float __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern float fmodf(float __x, float __y) __attribute__((__nothrow__, __leaf__));
extern float __fmodf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern int isinff(float __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int finitef(float __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern float dremf(float __x, float __y) __attribute__((__nothrow__, __leaf__));
extern float __dremf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern float significandf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __significandf(float __x) __attribute__((__nothrow__, __leaf__));
extern float copysignf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern float nanf(const char *__tagb) __attribute__((__nothrow__, __leaf__));
extern float __nanf(const char *__tagb) __attribute__((__nothrow__, __leaf__));
extern int isnanf(float __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern float j0f(float) __attribute__((__nothrow__, __leaf__));
extern float __j0f(float) __attribute__((__nothrow__, __leaf__));
extern float j1f(float) __attribute__((__nothrow__, __leaf__));
extern float __j1f(float) __attribute__((__nothrow__, __leaf__));
extern float jnf(int, float) __attribute__((__nothrow__, __leaf__));
extern float __jnf(int, float) __attribute__((__nothrow__, __leaf__));
extern float y0f(float) __attribute__((__nothrow__, __leaf__));
extern float __y0f(float) __attribute__((__nothrow__, __leaf__));
extern float y1f(float) __attribute__((__nothrow__, __leaf__));
extern float __y1f(float) __attribute__((__nothrow__, __leaf__));
extern float ynf(int, float) __attribute__((__nothrow__, __leaf__));
extern float __ynf(int, float) __attribute__((__nothrow__, __leaf__));
extern float erff(float) __attribute__((__nothrow__, __leaf__));
extern float __erff(float) __attribute__((__nothrow__, __leaf__));
extern float erfcf(float) __attribute__((__nothrow__, __leaf__));
extern float __erfcf(float) __attribute__((__nothrow__, __leaf__));
extern float lgammaf(float) __attribute__((__nothrow__, __leaf__));
extern float __lgammaf(float) __attribute__((__nothrow__, __leaf__));
extern float tgammaf(float) __attribute__((__nothrow__, __leaf__));
extern float __tgammaf(float) __attribute__((__nothrow__, __leaf__));
extern float gammaf(float) __attribute__((__nothrow__, __leaf__));
extern float __gammaf(float) __attribute__((__nothrow__, __leaf__));
extern float lgammaf_r(float, int *__signgamp)
    __attribute__((__nothrow__, __leaf__));
extern float __lgammaf_r(float, int *__signgamp)
    __attribute__((__nothrow__, __leaf__));
extern float rintf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __rintf(float __x) __attribute__((__nothrow__, __leaf__));
extern float nextafterf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern float __nextafterf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern float nexttowardf(float __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern float __nexttowardf(float __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern float nextdownf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __nextdownf(float __x) __attribute__((__nothrow__, __leaf__));
extern float nextupf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __nextupf(float __x) __attribute__((__nothrow__, __leaf__));
extern float remainderf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern float __remainderf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern float scalbnf(float __x, int __n) __attribute__((__nothrow__, __leaf__));
extern float __scalbnf(float __x, int __n)
    __attribute__((__nothrow__, __leaf__));
extern int ilogbf(float __x) __attribute__((__nothrow__, __leaf__));
extern int __ilogbf(float __x) __attribute__((__nothrow__, __leaf__));
extern long int llogbf(float __x) __attribute__((__nothrow__, __leaf__));
extern long int __llogbf(float __x) __attribute__((__nothrow__, __leaf__));
extern float scalblnf(float __x, long int __n)
    __attribute__((__nothrow__, __leaf__));
extern float __scalblnf(float __x, long int __n)
    __attribute__((__nothrow__, __leaf__));
extern float nearbyintf(float __x) __attribute__((__nothrow__, __leaf__));
extern float __nearbyintf(float __x) __attribute__((__nothrow__, __leaf__));
extern float roundf(float __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern float truncf(float __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern float remquof(float __x, float __y, int *__quo)
    __attribute__((__nothrow__, __leaf__));
extern float __remquof(float __x, float __y, int *__quo)
    __attribute__((__nothrow__, __leaf__));
extern long int lrintf(float __x) __attribute__((__nothrow__, __leaf__));
extern long int __lrintf(float __x) __attribute__((__nothrow__, __leaf__));
__extension__ extern long long int llrintf(float __x)
    __attribute__((__nothrow__, __leaf__));
extern long long int __llrintf(float __x)
    __attribute__((__nothrow__, __leaf__));
extern long int lroundf(float __x) __attribute__((__nothrow__, __leaf__));
extern long int __lroundf(float __x) __attribute__((__nothrow__, __leaf__));
__extension__ extern long long int llroundf(float __x)
    __attribute__((__nothrow__, __leaf__));
extern long long int __llroundf(float __x)
    __attribute__((__nothrow__, __leaf__));
extern float fdimf(float __x, float __y) __attribute__((__nothrow__, __leaf__));
extern float __fdimf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__));
extern float fmaxf(float __x, float __y) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern float fminf(float __x, float __y) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern float fmaf(float __x, float __y, float __z)
    __attribute__((__nothrow__, __leaf__));
extern float __fmaf(float __x, float __y, float __z)
    __attribute__((__nothrow__, __leaf__));
extern float roundevenf(float __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern __intmax_t fromfpf(float __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __intmax_t __fromfpf(float __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t ufromfpf(float __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t __ufromfpf(float __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __intmax_t fromfpxf(float __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __intmax_t __fromfpxf(float __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t ufromfpxf(float __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t __ufromfpxf(float __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern int canonicalizef(float *__cx, const float *__x)
    __attribute__((__nothrow__, __leaf__));
extern float fmaximumf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern float fminimumf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern float fmaximum_numf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern float fminimum_numf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern float fmaximum_magf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern float fminimum_magf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern float fmaximum_mag_numf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern float fminimum_mag_numf(float __x, float __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern float scalbf(float __x, float __n)
    __attribute__((__nothrow__, __leaf__));
extern float __scalbf(float __x, float __n)
    __attribute__((__nothrow__, __leaf__));
#undef _Mdouble_
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
#undef __MATH_DECLARING_FLOATN
#define _Mdouble_ long double
#define __MATH_PRECNAME(name, r) name##l##r
#define __MATH_DECLARING_DOUBLE 0
#define __MATH_DECLARING_FLOATN 0
#define __MATH_DECLARE_LDOUBLE 1
extern int __fpclassifyl(long double __value)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern int __signbitl(long double __value)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern int __isinfl(long double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __finitel(long double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __isnanl(long double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __iseqsigl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern int __issignalingl(long double __value)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double acosl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __acosl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double asinl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __asinl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double atanl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __atanl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double atan2l(long double __y, long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __atan2l(long double __y, long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double cosl(long double __x) __attribute__((__nothrow__, __leaf__));
extern long double __cosl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double sinl(long double __x) __attribute__((__nothrow__, __leaf__));
extern long double __sinl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double tanl(long double __x) __attribute__((__nothrow__, __leaf__));
extern long double __tanl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double acospil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __acospil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double acospil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __acospil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double asinpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __asinpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double asinpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __asinpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double atanpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __atanpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double atanpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __atanpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double atan2pil(long double __y, long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __atan2pil(long double __y, long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double atan2pil(long double __y, long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __atan2pil(long double __y, long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double cospil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __cospil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double sinpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __sinpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double tanpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __tanpil(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double coshl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __coshl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double sinhl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __sinhl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double tanhl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __tanhl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double acoshl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __acoshl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double asinhl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __asinhl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double atanhl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __atanhl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double expl(long double __x) __attribute__((__nothrow__, __leaf__));
extern long double __expl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double frexpl(long double __x, int *__exponent)
    __attribute__((__nothrow__, __leaf__));
extern long double __frexpl(long double __x, int *__exponent)
    __attribute__((__nothrow__, __leaf__));
extern long double ldexpl(long double __x, int __exponent)
    __attribute__((__nothrow__, __leaf__));
extern long double __ldexpl(long double __x, int __exponent)
    __attribute__((__nothrow__, __leaf__));
extern long double logl(long double __x) __attribute__((__nothrow__, __leaf__));
extern long double __logl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double log10l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __log10l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double modfl(long double __x, long double *__iptr)
    __attribute__((__nothrow__, __leaf__));
extern long double __modfl(long double __x, long double *__iptr)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2)));
extern long double exp10l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __exp10l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double exp2m1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __exp2m1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double exp10m1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __exp10m1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double log2p1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __log2p1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double log10p1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __log10p1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double logp1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __logp1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double expm1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __expm1l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double log1pl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __log1pl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double logbl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __logbl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double exp2l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __exp2l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double log2l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __log2l(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double powl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __powl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double sqrtl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __sqrtl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double hypotl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __hypotl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double cbrtl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __cbrtl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double compoundnl(long double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __compoundnl(long double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern long double pownl(long double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __pownl(long double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern long double powrl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __powrl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double rootnl(long double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __rootnl(long double __x, long long int __y)
    __attribute__((__nothrow__, __leaf__));
extern long double rsqrtl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __rsqrtl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double ceill(long double __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern long double fabsl(long double __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern long double floorl(long double __x)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double fmodl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __fmodl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern int isinfl(long double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int finitel(long double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern long double dreml(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __dreml(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double significandl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __significandl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double copysignl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double nanl(const char *__tagb)
    __attribute__((__nothrow__, __leaf__));
extern long double __nanl(const char *__tagb)
    __attribute__((__nothrow__, __leaf__));
extern int isnanl(long double __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern long double j0l(long double) __attribute__((__nothrow__, __leaf__));
extern long double __j0l(long double) __attribute__((__nothrow__, __leaf__));
extern long double j1l(long double) __attribute__((__nothrow__, __leaf__));
extern long double __j1l(long double) __attribute__((__nothrow__, __leaf__));
extern long double jnl(int, long double) __attribute__((__nothrow__, __leaf__));
extern long double __jnl(int, long double)
    __attribute__((__nothrow__, __leaf__));
extern long double y0l(long double) __attribute__((__nothrow__, __leaf__));
extern long double __y0l(long double) __attribute__((__nothrow__, __leaf__));
extern long double y1l(long double) __attribute__((__nothrow__, __leaf__));
extern long double __y1l(long double) __attribute__((__nothrow__, __leaf__));
extern long double ynl(int, long double) __attribute__((__nothrow__, __leaf__));
extern long double __ynl(int, long double)
    __attribute__((__nothrow__, __leaf__));
extern long double erfl(long double) __attribute__((__nothrow__, __leaf__));
extern long double __erfl(long double) __attribute__((__nothrow__, __leaf__));
extern long double erfcl(long double) __attribute__((__nothrow__, __leaf__));
extern long double __erfcl(long double) __attribute__((__nothrow__, __leaf__));
extern long double lgammal(long double) __attribute__((__nothrow__, __leaf__));
extern long double __lgammal(long double)
    __attribute__((__nothrow__, __leaf__));
extern long double tgammal(long double) __attribute__((__nothrow__, __leaf__));
extern long double __tgammal(long double)
    __attribute__((__nothrow__, __leaf__));
extern long double gammal(long double) __attribute__((__nothrow__, __leaf__));
extern long double __gammal(long double) __attribute__((__nothrow__, __leaf__));
extern long double lgammal_r(long double, int *__signgamp)
    __attribute__((__nothrow__, __leaf__));
extern long double __lgammal_r(long double, int *__signgamp)
    __attribute__((__nothrow__, __leaf__));
extern long double rintl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __rintl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double nextafterl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __nextafterl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double nexttowardl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __nexttowardl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double nextdownl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __nextdownl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double nextupl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __nextupl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double remainderl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __remainderl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double scalbnl(long double __x, int __n)
    __attribute__((__nothrow__, __leaf__));
extern long double __scalbnl(long double __x, int __n)
    __attribute__((__nothrow__, __leaf__));
extern int ilogbl(long double __x) __attribute__((__nothrow__, __leaf__));
extern int __ilogbl(long double __x) __attribute__((__nothrow__, __leaf__));
extern long int llogbl(long double __x) __attribute__((__nothrow__, __leaf__));
extern long int __llogbl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double scalblnl(long double __x, long int __n)
    __attribute__((__nothrow__, __leaf__));
extern long double __scalblnl(long double __x, long int __n)
    __attribute__((__nothrow__, __leaf__));
extern long double nearbyintl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double __nearbyintl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double roundl(long double __x)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double truncl(long double __x)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double remquol(long double __x, long double __y, int *__quo)
    __attribute__((__nothrow__, __leaf__));
extern long double __remquol(long double __x, long double __y, int *__quo)
    __attribute__((__nothrow__, __leaf__));
extern long int lrintl(long double __x) __attribute__((__nothrow__, __leaf__));
extern long int __lrintl(long double __x)
    __attribute__((__nothrow__, __leaf__));
__extension__ extern long long int llrintl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long long int __llrintl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long int lroundl(long double __x) __attribute__((__nothrow__, __leaf__));
extern long int __lroundl(long double __x)
    __attribute__((__nothrow__, __leaf__));
__extension__ extern long long int llroundl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long long int __llroundl(long double __x)
    __attribute__((__nothrow__, __leaf__));
extern long double fdiml(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double __fdiml(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern long double fmaxl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double fminl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double fmal(long double __x, long double __y, long double __z)
    __attribute__((__nothrow__, __leaf__));
extern long double __fmal(long double __x, long double __y, long double __z)
    __attribute__((__nothrow__, __leaf__));
extern long double roundevenl(long double __x)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern __intmax_t fromfpl(long double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __intmax_t __fromfpl(long double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t ufromfpl(long double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t __ufromfpl(long double __x, int __round,
                              unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __intmax_t fromfpxl(long double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __intmax_t __fromfpxl(long double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t ufromfpxl(long double __x, int __round, unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern __uintmax_t __ufromfpxl(long double __x, int __round,
                               unsigned int __width)
    __attribute__((__nothrow__, __leaf__));
extern int canonicalizel(long double *__cx, const long double *__x)
    __attribute__((__nothrow__, __leaf__));
extern long double fmaximuml(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double fminimuml(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double fmaximum_numl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double fminimum_numl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double fmaximum_magl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double fminimum_magl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double fmaximum_mag_numl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double fminimum_mag_numl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern long double scalbl(long double __x, long double __n)
    __attribute__((__nothrow__, __leaf__));
extern long double __scalbl(long double __x, long double __n)
    __attribute__((__nothrow__, __leaf__));
#undef _Mdouble_
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
#undef __MATH_DECLARING_FLOATN
#define _Mdouble_ _Float32
#define __MATH_PRECNAME(name, r) name##f32##r
#define __MATH_DECLARING_DOUBLE 0
#define __MATH_DECLARING_FLOATN 1
#undef _Mdouble_
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
#undef __MATH_DECLARING_FLOATN
#define _Mdouble_ _Float64
#define __MATH_PRECNAME(name, r) name##f64##r
#define __MATH_DECLARING_DOUBLE 0
#define __MATH_DECLARING_FLOATN 1
#undef _Mdouble_
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
#undef __MATH_DECLARING_FLOATN
#define _Mdouble_ _Float128
#define __MATH_PRECNAME(name, r) name##f128##r
#define __MATH_DECLARING_DOUBLE 0
#define __MATH_DECLARING_FLOATN 1
extern int __fpclassifyf128(_Float128 __value)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern int __signbitf128(_Float128 __value)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern int __isinff128(_Float128 __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __finitef128(_Float128 __value)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern int __isnanf128(_Float128 __value) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int __iseqsigf128(_Float128 __x, _Float128 __y)
    __attribute__((__nothrow__, __leaf__));
extern int __issignalingf128(_Float128 __value)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
#undef _Mdouble_
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
#undef __MATH_DECLARING_FLOATN
#define _Mdouble_ _Float32x
#define __MATH_PRECNAME(name, r) name##f32x##r
#define __MATH_DECLARING_DOUBLE 0
#define __MATH_DECLARING_FLOATN 1
#undef _Mdouble_
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
#undef __MATH_DECLARING_FLOATN
#define _Mdouble_ _Float64x
#define __MATH_PRECNAME(name, r) name##f64x##r
#define __MATH_DECLARING_DOUBLE 0
#define __MATH_DECLARING_FLOATN 1
#undef _Mdouble_
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
#undef __MATH_DECLARING_FLOATN
#undef __MATHDECL_1_IMPL
#undef __MATHDECL_1
#undef __MATHDECL_ALIAS
#undef __MATHDECL
#undef __MATHCALL
#define __MATHCALL_NARROW_ARGS_1 (_Marg_ __x)
#define __MATHCALL_NARROW_ARGS_2 (_Marg_ __x, _Marg_ __y)
#define __MATHCALL_NARROW_ARGS_3 (_Marg_ __x, _Marg_ __y, _Marg_ __z)
#define __MATHCALL_NARROW_NORMAL(func, nargs)                                  \
  extern _Mret_ func __MATHCALL_NARROW_ARGS_##nargs __THROW
#define __MATHCALL_NARROW_REDIR(func, redir, nargs)                            \
  extern _Mret_ __REDIRECT_NTH(func, __MATHCALL_NARROW_ARGS_##nargs, redir)
#define __MATHCALL_NARROW(func, redir, nargs)                                  \
  __MATHCALL_NARROW_NORMAL(func, nargs)
#define _Mret_ float
#define _Marg_ double
#define __MATHCALL_NAME(name) f##name
extern float fadd(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern float fdiv(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern float ffma(double __x, double __y, double __z)
    __attribute__((__nothrow__, __leaf__));
extern float fmul(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
extern float fsqrt(double __x) __attribute__((__nothrow__, __leaf__));
extern float fsub(double __x, double __y)
    __attribute__((__nothrow__, __leaf__));
#undef _Mret_
#undef _Marg_
#undef __MATHCALL_NAME
#define _Mret_ float
#define _Marg_ long double
#define __MATHCALL_NAME(name) f##name##l
extern float faddl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern float fdivl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern float ffmal(long double __x, long double __y, long double __z)
    __attribute__((__nothrow__, __leaf__));
extern float fmull(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern float fsqrtl(long double __x) __attribute__((__nothrow__, __leaf__));
extern float fsubl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
#undef _Mret_
#undef _Marg_
#undef __MATHCALL_NAME
#define _Mret_ double
#define _Marg_ long double
#define __MATHCALL_NAME(name) d##name##l
extern double daddl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern double ddivl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern double dfmal(long double __x, long double __y, long double __z)
    __attribute__((__nothrow__, __leaf__));
extern double dmull(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
extern double dsqrtl(long double __x) __attribute__((__nothrow__, __leaf__));
extern double dsubl(long double __x, long double __y)
    __attribute__((__nothrow__, __leaf__));
#undef _Mret_
#undef _Marg_
#undef __MATHCALL_NAME
#undef __MATHCALL_NARROW_ARGS_1
#undef __MATHCALL_NARROW_ARGS_2
#undef __MATHCALL_NARROW_ARGS_3
#undef __MATHCALL_NARROW_NORMAL
#undef __MATHCALL_NARROW_REDIR
#undef __MATHCALL_NARROW
extern int signgam;
#define __MATH_TG_F32(FUNC, ARGS)                                              \
  _Float32:                                                                    \
  FUNC##f ARGS,
#define __MATH_TG_F64X(FUNC, ARGS)                                             \
  _Float64x:                                                                   \
  FUNC##l ARGS,
#define __MATH_TG(TG_ARG, FUNC, ARGS)                                          \
  _Generic((TG_ARG),                                                           \
      float: FUNC##f ARGS,                                                     \
      __MATH_TG_F32(FUNC, ARGS) default: FUNC ARGS,                            \
      long double: FUNC##l ARGS,                                               \
      __MATH_TG_F64X(FUNC, ARGS) _Float128: FUNC##f128 ARGS)
enum {
  FP_NAN =
#define FP_NAN 0
      0,
  FP_INFINITE =
#define FP_INFINITE 1
      1,
  FP_ZERO =
#define FP_ZERO 2
      2,
  FP_SUBNORMAL =
#define FP_SUBNORMAL 3
      3,
  FP_NORMAL =
#define FP_NORMAL 4
      4
};
#define fpclassify(x)                                                          \
  __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, x)
#define signbit(x) __builtin_signbit(x)
#define isfinite(x) __builtin_isfinite(x)
#define isnormal(x) __builtin_isnormal(x)
#define isnan(x) __builtin_isnan(x)
#define isinf(x) __builtin_isinf_sign(x)
#define MATH_ERRNO 1
#define MATH_ERREXCEPT 2
#define math_errhandling (MATH_ERRNO | MATH_ERREXCEPT)
extern int __iscanonicall(long double __x)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
#define __iscanonicalf(x) ((void)(__typeof(x))(x), 1)
#define __iscanonical(x) ((void)(__typeof(x))(x), 1)
#define __iscanonicalf128(x) ((void)(__typeof(x))(x), 1)
#define iscanonical(x) __MATH_TG((x), __iscanonical, (x))
#define issignaling(x) __MATH_TG((x), __issignaling, (x))
#define issubnormal(x) (fpclassify(x) == FP_SUBNORMAL)
#define iszero(x) (((__typeof(x))(x)) == 0)
#define M_E 2.7182818284590452354
#define M_LOG2E 1.4426950408889634074
#define M_LOG10E 0.43429448190325182765
#define M_LN2 0.69314718055994530942
#define M_LN10 2.30258509299404568402
#define M_PI 3.14159265358979323846
#define M_PI_2 1.57079632679489661923
#define M_PI_4 0.78539816339744830962
#define M_1_PI 0.31830988618379067154
#define M_2_PI 0.63661977236758134308
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2 1.41421356237309504880
#define M_SQRT1_2 0.70710678118654752440
#define isgreater(x, y) __builtin_isgreater(x, y)
#define isgreaterequal(x, y) __builtin_isgreaterequal(x, y)
#define isless(x, y) __builtin_isless(x, y)
#define islessequal(x, y) __builtin_islessequal(x, y)
#define islessgreater(x, y) __builtin_islessgreater(x, y)
#define isunordered(x, y) __builtin_isunordered(x, y)
#define __MATH_EVAL_FMT2(x, y) ((x) + (y) + 0.0f)
#define iseqsig(x, y) __MATH_TG(__MATH_EVAL_FMT2(x, y), __iseqsig, ((x), (y)))

#define _STDBOOL_H
#define __bool_true_false_are_defined 1
#define _STDDEF_H
#define _STDDEF_H_
#define _ANSI_STDDEF_H
#define _PTRDIFF_T
#define _T_PTRDIFF_
#define _T_PTRDIFF
#define __PTRDIFF_T
#define _PTRDIFF_T_
#define _BSD_PTRDIFF_T_
#define ___int_ptrdiff_t_h
#define _GCC_PTRDIFF_T
#define _PTRDIFF_T_DECLARED
#define __DEFINED_ptrdiff_t
typedef long int ptrdiff_t;
#undef __need_ptrdiff_t
#define __size_t__
#define __SIZE_T__
#define _SIZE_T
#define _SYS_SIZE_T_H
#define _T_SIZE_
#define _T_SIZE
#define __SIZE_T
#define _SIZE_T_
#define _BSD_SIZE_T_
#define _SIZE_T_DEFINED_
#define _SIZE_T_DEFINED
#define _BSD_SIZE_T_DEFINED_
#define _SIZE_T_DECLARED
#define __DEFINED_size_t
#define ___int_size_t_h
#define _GCC_SIZE_T
#define _SIZET_
#define __size_t
typedef long unsigned int size_t;
#undef __need_size_t
#define __wchar_t__
#define __WCHAR_T__
#define _WCHAR_T
#define _T_WCHAR_
#define _T_WCHAR
#define __WCHAR_T
#define _WCHAR_T_
#define _BSD_WCHAR_T_
#define _WCHAR_T_DEFINED_
#define _WCHAR_T_DEFINED
#define _WCHAR_T_H
#define ___int_wchar_t_h
#define __INT_WCHAR_T_H
#define _GCC_WCHAR_T
#define _WCHAR_T_DECLARED
#define __DEFINED_wchar_t
#undef _BSD_WCHAR_T_
typedef int wchar_t;
#undef __need_wchar_t
#undef NULL
#define NULL ((void *)0)
#undef __need_NULL
#undef offsetof
#define offsetof(TYPE, MEMBER) __builtin_offsetof(TYPE, MEMBER)
#define _GCC_MAX_ALIGN_T
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
#define _GCC_NULLPTR_T
typedef __typeof__(nullptr) nullptr_t;
#define unreachable() (__builtin_unreachable())
#define __STDC_VERSION_STDDEF_H__ 202311L
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#define _STDINT_H 1
#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#undef __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#undef __GLIBC_USE_LIB_EXT2
#define __GLIBC_USE_LIB_EXT2 0
#undef __GLIBC_USE_IEC_60559_BFP_EXT
#define __GLIBC_USE_IEC_60559_BFP_EXT 0
#undef __GLIBC_USE_IEC_60559_BFP_EXT_C23
#define __GLIBC_USE_IEC_60559_BFP_EXT_C23 1
#undef __GLIBC_USE_IEC_60559_EXT
#define __GLIBC_USE_IEC_60559_EXT 0
#undef __GLIBC_USE_IEC_60559_FUNCS_EXT
#define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
#undef __GLIBC_USE_IEC_60559_FUNCS_EXT_C23
#define __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 1
#undef __GLIBC_USE_IEC_60559_TYPES_EXT
#define __GLIBC_USE_IEC_60559_TYPES_EXT 0
#define _BITS_WCHAR_H 1
#define __WCHAR_MAX __WCHAR_MAX__
#define __WCHAR_MIN __WCHAR_MIN__
#define __WORDSIZE 64
#define __WORDSIZE_TIME64_COMPAT32 1
#define __SYSCALL_WORDSIZE 64
#define _BITS_STDINT_INTN_H 1
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
#define _BITS_STDINT_UINTN_H 1
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
#define _BITS_STDINT_LEAST_H 1
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;
#define __intptr_t_defined
typedef unsigned long int uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
#define __INT64_C(c) c##L
#define __UINT64_C(c) c##UL
#define INT8_MIN (-128)
#define INT16_MIN (-32767 - 1)
#define INT32_MIN (-2147483647 - 1)
#define INT64_MIN (-__INT64_C(9223372036854775807) - 1)
#define INT8_MAX (127)
#define INT16_MAX (32767)
#define INT32_MAX (2147483647)
#define INT64_MAX (__INT64_C(9223372036854775807))
#define UINT8_MAX (255)
#define UINT16_MAX (65535)
#define UINT32_MAX (4294967295U)
#define UINT64_MAX (__UINT64_C(18446744073709551615))
#define INT_LEAST8_MIN (-128)
#define INT_LEAST16_MIN (-32767 - 1)
#define INT_LEAST32_MIN (-2147483647 - 1)
#define INT_LEAST64_MIN (-__INT64_C(9223372036854775807) - 1)
#define INT_LEAST8_MAX (127)
#define INT_LEAST16_MAX (32767)
#define INT_LEAST32_MAX (2147483647)
#define INT_LEAST64_MAX (__INT64_C(9223372036854775807))
#define UINT_LEAST8_MAX (255)
#define UINT_LEAST16_MAX (65535)
#define UINT_LEAST32_MAX (4294967295U)
#define UINT_LEAST64_MAX (__UINT64_C(18446744073709551615))
#define INT_FAST8_MIN (-128)
#define INT_FAST16_MIN (-9223372036854775807L - 1)
#define INT_FAST32_MIN (-9223372036854775807L - 1)
#define INT_FAST64_MIN (-__INT64_C(9223372036854775807) - 1)
#define INT_FAST8_MAX (127)
#define INT_FAST16_MAX (9223372036854775807L)
#define INT_FAST32_MAX (9223372036854775807L)
#define INT_FAST64_MAX (__INT64_C(9223372036854775807))
#define UINT_FAST8_MAX (255)
#define UINT_FAST16_MAX (18446744073709551615UL)
#define UINT_FAST32_MAX (18446744073709551615UL)
#define UINT_FAST64_MAX (__UINT64_C(18446744073709551615))
#define INTPTR_MIN (-9223372036854775807L - 1)
#define INTPTR_MAX (9223372036854775807L)
#define UINTPTR_MAX (18446744073709551615UL)
#define INTMAX_MIN (-__INT64_C(9223372036854775807) - 1)
#define INTMAX_MAX (__INT64_C(9223372036854775807))
#define UINTMAX_MAX (__UINT64_C(18446744073709551615))
#define PTRDIFF_MIN (-9223372036854775807L - 1)
#define PTRDIFF_MAX (9223372036854775807L)
#define SIG_ATOMIC_MIN (-2147483647 - 1)
#define SIG_ATOMIC_MAX (2147483647)
#define SIZE_MAX (18446744073709551615UL)
#define WCHAR_MIN __WCHAR_MIN
#define WCHAR_MAX __WCHAR_MAX
#define WINT_MIN (0u)
#define WINT_MAX (4294967295u)
#define INT8_C(c) c
#define INT16_C(c) c
#define INT32_C(c) c
#define INT64_C(c) c##L
#define UINT8_C(c) c
#define UINT16_C(c) c
#define UINT32_C(c) c##U
#define UINT64_C(c) c##UL
#define INTMAX_C(c) c##L
#define UINTMAX_C(c) c##UL
#define INT8_WIDTH 8
#define UINT8_WIDTH 8
#define INT16_WIDTH 16
#define UINT16_WIDTH 16
#define INT32_WIDTH 32
#define UINT32_WIDTH 32
#define INT64_WIDTH 64
#define UINT64_WIDTH 64
#define INT_LEAST8_WIDTH 8
#define UINT_LEAST8_WIDTH 8
#define INT_LEAST16_WIDTH 16
#define UINT_LEAST16_WIDTH 16
#define INT_LEAST32_WIDTH 32
#define UINT_LEAST32_WIDTH 32
#define INT_LEAST64_WIDTH 64
#define UINT_LEAST64_WIDTH 64
#define INT_FAST8_WIDTH 8
#define UINT_FAST8_WIDTH 8
#define INT_FAST16_WIDTH __WORDSIZE
#define UINT_FAST16_WIDTH __WORDSIZE
#define INT_FAST32_WIDTH __WORDSIZE
#define UINT_FAST32_WIDTH __WORDSIZE
#define INT_FAST64_WIDTH 64
#define UINT_FAST64_WIDTH 64
#define INTPTR_WIDTH __WORDSIZE
#define UINTPTR_WIDTH __WORDSIZE
#define INTMAX_WIDTH 64
#define UINTMAX_WIDTH 64
#define PTRDIFF_WIDTH __WORDSIZE
#define SIG_ATOMIC_WIDTH 32
#define SIZE_WIDTH __WORDSIZE
#define WCHAR_WIDTH 32
#define WINT_WIDTH 32
#pragma GCC diagnostic pop
#define _GCC_WRAP_STDINT_H
#define _STDIO_H 1
#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#undef __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#undef __GLIBC_USE_LIB_EXT2
#define __GLIBC_USE_LIB_EXT2 0
#undef __GLIBC_USE_IEC_60559_BFP_EXT
#define __GLIBC_USE_IEC_60559_BFP_EXT 0
#undef __GLIBC_USE_IEC_60559_BFP_EXT_C23
#define __GLIBC_USE_IEC_60559_BFP_EXT_C23 1
#undef __GLIBC_USE_IEC_60559_EXT
#define __GLIBC_USE_IEC_60559_EXT 0
#undef __GLIBC_USE_IEC_60559_FUNCS_EXT
#define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
#undef __GLIBC_USE_IEC_60559_FUNCS_EXT_C23
#define __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 1
#undef __GLIBC_USE_IEC_60559_TYPES_EXT
#define __GLIBC_USE_IEC_60559_TYPES_EXT 0

#define __need_size_t
#define __need_NULL
#undef __need_ptrdiff_t
#undef __need_size_t
#undef __need_wchar_t
#undef NULL
#define NULL ((void *)0)
#undef __need_NULL
#undef offsetof
#define offsetof(TYPE, MEMBER) __builtin_offsetof(TYPE, MEMBER)
#define __need___va_list
#undef __need___va_list
#define __GNUC_VA_LIST
typedef __builtin_va_list __gnuc_va_list;
#define _____fpos_t_defined 1
#define ____mbstate_t_defined 1
typedef struct {
  int __count;
  union {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
typedef struct _G_fpos_t {
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
#define _____fpos64_t_defined 1
typedef struct _G_fpos64_t {
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
#define ____FILE_defined 1
struct _IO_FILE;
typedef struct _IO_FILE __FILE;
#define __FILE_defined 1
struct _IO_FILE;
typedef struct _IO_FILE FILE;
#define __struct_FILE_defined 1
#define __WORDSIZE 64
#define __WORDSIZE_TIME64_COMPAT32 1
#define __SYSCALL_WORDSIZE 64
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;
typedef void _IO_lock_t;
struct _IO_FILE {
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2 : 24;
  char _short_backupbuf[1];
  __off_t _old_offset;
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  struct _IO_FILE **_prevchain;
  int _mode;
  int _unused3;
  __uint64_t _total_written;
  char _unused2[12 * sizeof(int) - 5 * sizeof(void *)];
};
#define __getc_unlocked_body(_fp)                                              \
  (__glibc_unlikely((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end)                \
       ? __uflow(_fp)                                                          \
       : *(unsigned char *)(_fp)->_IO_read_ptr++)
#define __putc_unlocked_body(_ch, _fp)                                         \
  (__glibc_unlikely((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end)              \
       ? __overflow(_fp, (unsigned char)(_ch))                                 \
       : (unsigned char)(*(_fp)->_IO_write_ptr++ = (_ch)))
#define _IO_EOF_SEEN 0x0010
#define __feof_unlocked_body(_fp) (((_fp)->_flags & _IO_EOF_SEEN) != 0)
#define _IO_ERR_SEEN 0x0020
#define __ferror_unlocked_body(_fp) (((_fp)->_flags & _IO_ERR_SEEN) != 0)
#define _IO_USER_LOCK 0x8000
#define __cookie_io_functions_t_defined 1
typedef __ssize_t cookie_read_function_t(void *__cookie, char *__buf,
                                         size_t __nbytes);
typedef __ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
                                          size_t __nbytes);
typedef int cookie_seek_function_t(void *__cookie, __off64_t *__pos, int __w);
typedef int cookie_close_function_t(void *__cookie);
typedef struct _IO_cookie_io_functions_t {
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
typedef __gnuc_va_list va_list;
#define _VA_LIST_DEFINED
typedef __off_t off_t;
#define __off_t_defined
typedef __ssize_t ssize_t;
#define __ssize_t_defined
typedef __fpos_t fpos_t;
#define _IOFBF 0
#define _IOLBF 1
#define _IONBF 2
#define BUFSIZ 8192
#define EOF (-1)
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2
#define P_tmpdir "/tmp"
#define L_tmpnam 20
#define TMP_MAX 238328
#define _BITS_STDIO_LIM_H 1
#define FILENAME_MAX 4096
#define L_ctermid 9
#undef FOPEN_MAX
#define FOPEN_MAX 16
#define _PRINTF_NAN_LEN_MAX 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
#define stdin stdin
#define stdout stdout
#define stderr stderr
extern int remove(const char *__filename)
    __attribute__((__nothrow__, __leaf__));
extern int rename(const char *__old, const char *__new)
    __attribute__((__nothrow__, __leaf__));
extern int renameat(int __oldfd, const char *__old, int __newfd,
                    const char *__new) __attribute__((__nothrow__, __leaf__));
extern int fclose(FILE *__stream) __attribute__((__nonnull__(1)));
#undef __attr_dealloc_fclose
#define __attr_dealloc_fclose __attr_dealloc(fclose, 1)
extern FILE *tmpfile(void) __attribute__((__malloc__))
__attribute__((__malloc__(fclose, 1)));
extern char *tmpnam(char[20]) __attribute__((__nothrow__, __leaf__));
extern char *tmpnam_r(char __s[20]) __attribute__((__nothrow__, __leaf__));
extern char *tempnam(const char *__dir, const char *__pfx)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__malloc__))
    __attribute__((__malloc__(__builtin_free, 1)));
extern int fflush(FILE *__stream);
extern int fflush_unlocked(FILE *__stream);
extern FILE *fopen(const char *__restrict __filename,
                   const char *__restrict __modes) __attribute__((__malloc__))
__attribute__((__malloc__(fclose, 1)));
extern FILE *freopen(const char *__restrict __filename,
                     const char *__restrict __modes, FILE *__restrict __stream)
    __attribute__((__nonnull__(3)));
extern FILE *fdopen(int __fd, const char *__modes)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__malloc__))
    __attribute__((__malloc__(fclose, 1)));
extern FILE *fopencookie(void *__restrict __magic_cookie,
                         const char *__restrict __modes,
                         cookie_io_functions_t __io_funcs)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__malloc__))
    __attribute__((__malloc__(fclose, 1)));
extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__malloc__))
    __attribute__((__malloc__(fclose, 1)));
extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__malloc__))
    __attribute__((__malloc__(fclose, 1)));
extern void setbuf(FILE *__restrict __stream, char *__restrict __buf)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern int setvbuf(FILE *__restrict __stream, char *__restrict __buf,
                   int __modes, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern void setbuffer(FILE *__restrict __stream, char *__restrict __buf,
                      size_t __size) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern void setlinebuf(FILE *__stream) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int fprintf(FILE *__restrict __stream, const char *__restrict __format,
                   ...) __attribute__((__nonnull__(1)));
extern int printf(const char *__restrict __format, ...);
extern int sprintf(char *__restrict __s, const char *__restrict __format, ...)
    __attribute__((__nothrow__));
extern int vfprintf(FILE *__restrict __s, const char *__restrict __format,
                    __gnuc_va_list __arg) __attribute__((__nonnull__(1)));
extern int vprintf(const char *__restrict __format, __gnuc_va_list __arg);
extern int vsprintf(char *__restrict __s, const char *__restrict __format,
                    __gnuc_va_list __arg) __attribute__((__nothrow__));
extern int snprintf(char *__restrict __s, size_t __maxlen,
                    const char *__restrict __format, ...)
    __attribute__((__nothrow__)) __attribute__((__format__(__printf__, 3, 4)));
extern int vsnprintf(char *__restrict __s, size_t __maxlen,
                     const char *__restrict __format, __gnuc_va_list __arg)
    __attribute__((__nothrow__)) __attribute__((__format__(__printf__, 3, 0)));
extern int vasprintf(char **__restrict __ptr, const char *__restrict __f,
                     __gnuc_va_list __arg) __attribute__((__nothrow__))
__attribute__((__format__(__printf__, 2, 0)));
extern int __asprintf(char **__restrict __ptr, const char *__restrict __fmt,
                      ...) __attribute__((__nothrow__))
__attribute__((__format__(__printf__, 2, 3)));
extern int asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...)
    __attribute__((__nothrow__)) __attribute__((__format__(__printf__, 2, 3)));
extern int vdprintf(int __fd, const char *__restrict __fmt,
                    __gnuc_va_list __arg)
    __attribute__((__format__(__printf__, 2, 0)));
extern int dprintf(int __fd, const char *__restrict __fmt, ...)
    __attribute__((__format__(__printf__, 2, 3)));
extern int fscanf(FILE *__restrict __stream, const char *__restrict __format,
                  ...) __attribute__((__nonnull__(1)));
extern int scanf(const char *__restrict __format, ...);
extern int sscanf(const char *__restrict __s, const char *__restrict __format,
                  ...) __attribute__((__nothrow__, __leaf__));
extern int fscanf(FILE *__restrict __stream, const char *__restrict __format,
                  ...) __asm__(""
                               "__isoc23_fscanf")
    __attribute__((__nonnull__(1)));
extern int scanf(const char *__restrict __format,
                 ...) __asm__(""
                              "__isoc23_scanf");
extern int sscanf(const char *__restrict __s, const char *__restrict __format,
                  ...) __asm__(""
                               "__isoc23_sscanf")
    __attribute__((__nothrow__, __leaf__));
extern int vfscanf(FILE *__restrict __s, const char *__restrict __format,
                   __gnuc_va_list __arg)
    __attribute__((__format__(__scanf__, 2, 0)))
    __attribute__((__nonnull__(1)));
extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg)
    __attribute__((__format__(__scanf__, 1, 0)));
extern int vsscanf(const char *__restrict __s, const char *__restrict __format,
                   __gnuc_va_list __arg) __attribute__((__nothrow__, __leaf__))
__attribute__((__format__(__scanf__, 2, 0)));
extern int vfscanf(FILE *__restrict __s, const char *__restrict __format,
                   __gnuc_va_list __arg) __asm__(""
                                                 "__isoc23_vfscanf")
    __attribute__((__format__(__scanf__, 2, 0)))
    __attribute__((__nonnull__(1)));
extern int vscanf(const char *__restrict __format,
                  __gnuc_va_list __arg) __asm__(""
                                                "__isoc23_vscanf")
    __attribute__((__format__(__scanf__, 1, 0)));
extern int vsscanf(const char *__restrict __s, const char *__restrict __format,
                   __gnuc_va_list __arg) __asm__(""
                                                 "__isoc23_vsscanf")
    __attribute__((__nothrow__, __leaf__))
    __attribute__((__format__(__scanf__, 2, 0)));
extern int fgetc(FILE *__stream) __attribute__((__nonnull__(1)));
extern int getc(FILE *__stream) __attribute__((__nonnull__(1)));
extern int getchar(void);
extern int getc_unlocked(FILE *__stream) __attribute__((__nonnull__(1)));
extern int getchar_unlocked(void);
extern int fgetc_unlocked(FILE *__stream) __attribute__((__nonnull__(1)));
extern int fputc(int __c, FILE *__stream) __attribute__((__nonnull__(2)));
extern int putc(int __c, FILE *__stream) __attribute__((__nonnull__(2)));
extern int putchar(int __c);
extern int fputc_unlocked(int __c, FILE *__stream)
    __attribute__((__nonnull__(2)));
extern int putc_unlocked(int __c, FILE *__stream)
    __attribute__((__nonnull__(2)));
extern int putchar_unlocked(int __c);
extern int getw(FILE *__stream) __attribute__((__nonnull__(1)));
extern int putw(int __w, FILE *__stream) __attribute__((__nonnull__(2)));
extern char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream)
    __attribute__((__access__(__write_only__, 1, 2)))
    __attribute__((__nonnull__(3)));
extern __ssize_t __getdelim(char **__restrict __lineptr, size_t *__restrict __n,
                            int __delimiter, FILE *__restrict __stream)
    __attribute__((__nonnull__(4)));
extern __ssize_t getdelim(char **__restrict __lineptr, size_t *__restrict __n,
                          int __delimiter, FILE *__restrict __stream)
    __attribute__((__nonnull__(4)));
extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n,
                         FILE *__restrict __stream)
    __attribute__((__nonnull__(3)));
extern int fputs(const char *__restrict __s, FILE *__restrict __stream)
    __attribute__((__nonnull__(2)));
extern int puts(const char *__s);
extern int ungetc(int __c, FILE *__stream) __attribute__((__nonnull__(2)));
extern size_t fread(void *__restrict __ptr, size_t __size, size_t __n,
                    FILE *__restrict __stream) __attribute__((__nonnull__(4)));
extern size_t fwrite(const void *__restrict __ptr, size_t __size, size_t __n,
                     FILE *__restrict __s) __attribute__((__nonnull__(4)));
extern size_t fread_unlocked(void *__restrict __ptr, size_t __size, size_t __n,
                             FILE *__restrict __stream)
    __attribute__((__nonnull__(4)));
extern size_t fwrite_unlocked(const void *__restrict __ptr, size_t __size,
                              size_t __n, FILE *__restrict __stream)
    __attribute__((__nonnull__(4)));
extern int fseek(FILE *__stream, long int __off, int __whence)
    __attribute__((__nonnull__(1)));
extern long int ftell(FILE *__stream) __attribute__((__nonnull__(1)));
extern void rewind(FILE *__stream) __attribute__((__nonnull__(1)));
extern int fseeko(FILE *__stream, __off_t __off, int __whence)
    __attribute__((__nonnull__(1)));
extern __off_t ftello(FILE *__stream) __attribute__((__nonnull__(1)));
extern int fgetpos(FILE *__restrict __stream, fpos_t *__restrict __pos)
    __attribute__((__nonnull__(1)));
extern int fsetpos(FILE *__stream, const fpos_t *__pos)
    __attribute__((__nonnull__(1)));
extern void clearerr(FILE *__stream) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int feof(FILE *__stream) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int ferror(FILE *__stream) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern void clearerr_unlocked(FILE *__stream)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern int feof_unlocked(FILE *__stream) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int ferror_unlocked(FILE *__stream)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern void perror(const char *__s) __attribute__((__cold__));
extern int fileno(FILE *__stream) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int fileno_unlocked(FILE *__stream)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern int pclose(FILE *__stream) __attribute__((__nonnull__(1)));
extern FILE *popen(const char *__command, const char *__modes)
    __attribute__((__malloc__)) __attribute__((__malloc__(pclose, 1)));
extern char *ctermid(char *__s) __attribute__((__nothrow__, __leaf__))
__attribute__((__access__(__write_only__, 1)));
extern void flockfile(FILE *__stream) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int ftrylockfile(FILE *__stream) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern void funlockfile(FILE *__stream) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int __uflow(FILE *);
extern int __overflow(FILE *, int);

#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#undef __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#undef __GLIBC_USE_LIB_EXT2
#define __GLIBC_USE_LIB_EXT2 0
#undef __GLIBC_USE_IEC_60559_BFP_EXT
#define __GLIBC_USE_IEC_60559_BFP_EXT 0
#undef __GLIBC_USE_IEC_60559_BFP_EXT_C23
#define __GLIBC_USE_IEC_60559_BFP_EXT_C23 1
#undef __GLIBC_USE_IEC_60559_EXT
#define __GLIBC_USE_IEC_60559_EXT 0
#undef __GLIBC_USE_IEC_60559_FUNCS_EXT
#define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
#undef __GLIBC_USE_IEC_60559_FUNCS_EXT_C23
#define __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 1
#undef __GLIBC_USE_IEC_60559_TYPES_EXT
#define __GLIBC_USE_IEC_60559_TYPES_EXT 0
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#undef __need_ptrdiff_t
#undef __need_size_t
#undef __need_wchar_t
#undef NULL
#define NULL ((void *)0)
#undef __need_NULL
#undef offsetof
#define offsetof(TYPE, MEMBER) __builtin_offsetof(TYPE, MEMBER)

#define _STDLIB_H 1
#define WNOHANG 1
#define WUNTRACED 2
#define WSTOPPED 2
#define WEXITED 4
#define WCONTINUED 8
#define WNOWAIT 0x01000000
#define __WNOTHREAD 0x20000000
#define __WALL 0x40000000
#define __WCLONE 0x80000000
#define __WEXITSTATUS(status) (((status) & 0xff00) >> 8)
#define __WTERMSIG(status) ((status) & 0x7f)
#define __WSTOPSIG(status) __WEXITSTATUS(status)
#define __WIFEXITED(status) (__WTERMSIG(status) == 0)
#define __WIFSIGNALED(status) (((signed char)(((status) & 0x7f) + 1) >> 1) > 0)
#define __WIFSTOPPED(status) (((status) & 0xff) == 0x7f)
#define __WIFCONTINUED(status) ((status) == __W_CONTINUED)
#define __WCOREDUMP(status) ((status) & __WCOREFLAG)
#define __W_EXITCODE(ret, sig) ((ret) << 8 | (sig))
#define __W_STOPCODE(sig) ((sig) << 8 | 0x7f)
#define __W_CONTINUED 0xffff
#define __WCOREFLAG 0x80
#define WEXITSTATUS(status) __WEXITSTATUS(status)
#define WTERMSIG(status) __WTERMSIG(status)
#define WSTOPSIG(status) __WSTOPSIG(status)
#define WIFEXITED(status) __WIFEXITED(status)
#define WIFSIGNALED(status) __WIFSIGNALED(status)
#define WIFSTOPPED(status) __WIFSTOPPED(status)
#define WIFCONTINUED(status) __WIFCONTINUED(status)
typedef struct {
  int quot;
  int rem;
} div_t;
typedef struct {
  long int quot;
  long int rem;
} ldiv_t;
#define __ldiv_t_defined 1
__extension__ typedef struct {
  long long int quot;
  long long int rem;
} lldiv_t;
#define __lldiv_t_defined 1
#define RAND_MAX 2147483647
#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0
#define MB_CUR_MAX (__ctype_get_mb_cur_max())
extern size_t __ctype_get_mb_cur_max(void)
    __attribute__((__nothrow__, __leaf__));
extern double atof(const char *__nptr) __attribute__((__nothrow__, __leaf__))
__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern int atoi(const char *__nptr) __attribute__((__nothrow__, __leaf__))
__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern long int atol(const char *__nptr) __attribute__((__nothrow__, __leaf__))
__attribute__((__pure__)) __attribute__((__nonnull__(1)));
__extension__ extern long long int atoll(const char *__nptr)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1)));
extern double strtod(const char *__restrict __nptr, char **__restrict __endptr)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern float strtof(const char *__restrict __nptr, char **__restrict __endptr)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern long double strtold(const char *__restrict __nptr,
                           char **__restrict __endptr)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern long int strtol(const char *__restrict __nptr,
                       char **__restrict __endptr, int __base)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern unsigned long int strtoul(const char *__restrict __nptr,
                                 char **__restrict __endptr, int __base)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
__extension__ extern long long int
strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
__extension__ extern unsigned long long int
strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
__extension__ extern long long int
strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
__extension__ extern unsigned long long int
strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern long int strtol(const char *__restrict __nptr,
                       char **__restrict __endptr,
                       int __base) __asm__(""
                                           "__isoc23_strtol")
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern unsigned long int strtoul(const char *__restrict __nptr,
                                 char **__restrict __endptr,
                                 int __base) __asm__(""
                                                     "__isoc23_strtoul")
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
__extension__ extern long long int
strtoq(const char *__restrict __nptr, char **__restrict __endptr,
       int __base) __asm__(""
                           "__isoc23_strtoll")
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
__extension__ extern unsigned long long int
strtouq(const char *__restrict __nptr, char **__restrict __endptr,
        int __base) __asm__(""
                            "__isoc23_strtoull")
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
__extension__ extern long long int
strtoll(const char *__restrict __nptr, char **__restrict __endptr,
        int __base) __asm__(""
                            "__isoc23_strtoll")
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
__extension__ extern unsigned long long int
strtoull(const char *__restrict __nptr, char **__restrict __endptr,
         int __base) __asm__(""
                             "__isoc23_strtoull")
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern int strfromd(char *__dest, size_t __size, const char *__format,
                    double __f) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(3)));
extern int strfromf(char *__dest, size_t __size, const char *__format,
                    float __f) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(3)));
extern int strfroml(char *__dest, size_t __size, const char *__format,
                    long double __f) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(3)));
extern char *l64a(long int __n) __attribute__((__nothrow__, __leaf__));
extern long int a64l(const char *__s) __attribute__((__nothrow__, __leaf__))
__attribute__((__pure__)) __attribute__((__nonnull__(1)));
#define _SYS_TYPES_H 1

typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
#define __u_char_defined
typedef __loff_t loff_t;
typedef __ino_t ino_t;
#define __ino_t_defined
typedef __dev_t dev_t;
#define __dev_t_defined
typedef __gid_t gid_t;
#define __gid_t_defined
typedef __mode_t mode_t;
#define __mode_t_defined
typedef __nlink_t nlink_t;
#define __nlink_t_defined
typedef __uid_t uid_t;
#define __uid_t_defined
typedef __pid_t pid_t;
#define __pid_t_defined
typedef __id_t id_t;
#define __id_t_defined
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
#define __daddr_t_defined
typedef __key_t key_t;
#define __key_t_defined
#define __clock_t_defined 1
typedef __clock_t clock_t;
#define __clockid_t_defined 1
typedef __clockid_t clockid_t;
#define __time_t_defined 1
typedef __time_t time_t;
#define __timer_t_defined 1
typedef __timer_t timer_t;
#define __need_size_t
#undef __need_ptrdiff_t
#undef __need_size_t
#undef __need_wchar_t
#undef NULL
#define NULL ((void *)0)
#undef __need_NULL
#undef offsetof
#define offsetof(TYPE, MEMBER) __builtin_offsetof(TYPE, MEMBER)
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;
typedef int register_t __attribute__((__mode__(__word__)));
#define __BIT_TYPES_DEFINED__ 1
#define _ENDIAN_H 1
#define _BITS_ENDIAN_H 1
#define __LITTLE_ENDIAN 1234
#define __BIG_ENDIAN 4321
#define __PDP_ENDIAN 3412
#define _BITS_ENDIANNESS_H 1
#define __BYTE_ORDER __LITTLE_ENDIAN
#define __FLOAT_WORD_ORDER __BYTE_ORDER
#define __LONG_LONG_PAIR(HI, LO) LO, HI
#define LITTLE_ENDIAN __LITTLE_ENDIAN
#define BIG_ENDIAN __BIG_ENDIAN
#define PDP_ENDIAN __PDP_ENDIAN
#define BYTE_ORDER __BYTE_ORDER
#define _BITS_BYTESWAP_H 1
#define __bswap_constant_16(x)                                                 \
  ((__uint16_t)((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))
static __inline __uint16_t __bswap_16(__uint16_t __bsx) {
  return __builtin_bswap16(__bsx);
}
#define __bswap_constant_32(x)                                                 \
  ((((x) & 0xff000000u) >> 24) | (((x) & 0x00ff0000u) >> 8) |                  \
   (((x) & 0x0000ff00u) << 8) | (((x) & 0x000000ffu) << 24))
static __inline __uint32_t __bswap_32(__uint32_t __bsx) {
  return __builtin_bswap32(__bsx);
}
#define __bswap_constant_64(x)                                                 \
  ((((x) & 0xff00000000000000ull) >> 56) |                                     \
   (((x) & 0x00ff000000000000ull) >> 40) |                                     \
   (((x) & 0x0000ff0000000000ull) >> 24) |                                     \
   (((x) & 0x000000ff00000000ull) >> 8) |                                      \
   (((x) & 0x00000000ff000000ull) << 8) |                                      \
   (((x) & 0x0000000000ff0000ull) << 24) |                                     \
   (((x) & 0x000000000000ff00ull) << 40) |                                     \
   (((x) & 0x00000000000000ffull) << 56))
__extension__ static __inline __uint64_t __bswap_64(__uint64_t __bsx) {
  return __builtin_bswap64(__bsx);
}
#define _BITS_UINTN_IDENTITY_H 1
static __inline __uint16_t __uint16_identity(__uint16_t __x) { return __x; }
static __inline __uint32_t __uint32_identity(__uint32_t __x) { return __x; }
static __inline __uint64_t __uint64_identity(__uint64_t __x) { return __x; }
#define htobe16(x) __bswap_16(x)
#define htole16(x) __uint16_identity(x)
#define be16toh(x) __bswap_16(x)
#define le16toh(x) __uint16_identity(x)
#define htobe32(x) __bswap_32(x)
#define htole32(x) __uint32_identity(x)
#define be32toh(x) __bswap_32(x)
#define le32toh(x) __uint32_identity(x)
#define htobe64(x) __bswap_64(x)
#define htole64(x) __uint64_identity(x)
#define be64toh(x) __bswap_64(x)
#define le64toh(x) __uint64_identity(x)
#define _SYS_SELECT_H 1
#define __FD_ZERO(s)                                                           \
  do {                                                                         \
    unsigned int __i;                                                          \
    fd_set *__arr = (s);                                                       \
    for (__i = 0; __i < sizeof(fd_set) / sizeof(__fd_mask); ++__i)             \
      __FDS_BITS(__arr)[__i] = 0;                                              \
  } while (0)
#define __FD_SET(d, s) ((void)(__FDS_BITS(s)[__FD_ELT(d)] |= __FD_MASK(d)))
#define __FD_CLR(d, s) ((void)(__FDS_BITS(s)[__FD_ELT(d)] &= ~__FD_MASK(d)))
#define __FD_ISSET(d, s) ((__FDS_BITS(s)[__FD_ELT(d)] & __FD_MASK(d)) != 0)
#define __sigset_t_defined 1
#define ____sigset_t_defined
#define _SIGSET_NWORDS (1024 / (8 * sizeof(unsigned long int)))
typedef struct {
  unsigned long int __val[(1024 / (8 * sizeof(unsigned long int)))];
} __sigset_t;
typedef __sigset_t sigset_t;
#define __timeval_defined 1
struct timeval {
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
#define _STRUCT_TIMESPEC 1
struct timespec {
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
typedef __suseconds_t suseconds_t;
#define __suseconds_t_defined
typedef long int __fd_mask;
#undef __NFDBITS
#define __NFDBITS (8 * (int)sizeof(__fd_mask))
#define __FD_ELT(d) ((d) / __NFDBITS)
#define __FD_MASK(d) ((__fd_mask)(1UL << ((d) % __NFDBITS)))
typedef struct {
  __fd_mask __fds_bits[1024 / (8 * (int)sizeof(__fd_mask))];
#define __FDS_BITS(set) ((set)->__fds_bits)
} fd_set;
#define FD_SETSIZE __FD_SETSIZE
typedef __fd_mask fd_mask;
#define NFDBITS __NFDBITS
#define FD_SET(fd, fdsetp) __FD_SET(fd, fdsetp)
#define FD_CLR(fd, fdsetp) __FD_CLR(fd, fdsetp)
#define FD_ISSET(fd, fdsetp) __FD_ISSET(fd, fdsetp)
#define FD_ZERO(fdsetp) __FD_ZERO(fdsetp)

extern int select(int __nfds, fd_set *__restrict __readfds,
                  fd_set *__restrict __writefds, fd_set *__restrict __exceptfds,
                  struct timeval *__restrict __timeout);
extern int pselect(int __nfds, fd_set *__restrict __readfds,
                   fd_set *__restrict __writefds,
                   fd_set *__restrict __exceptfds,
                   const struct timespec *__restrict __timeout,
                   const __sigset_t *__restrict __sigmask);

typedef __blksize_t blksize_t;
#define __blksize_t_defined
typedef __blkcnt_t blkcnt_t;
#define __blkcnt_t_defined
typedef __fsblkcnt_t fsblkcnt_t;
#define __fsblkcnt_t_defined
typedef __fsfilcnt_t fsfilcnt_t;
#define __fsfilcnt_t_defined
#define _BITS_PTHREADTYPES_COMMON_H 1
#define _THREAD_SHARED_TYPES_H 1
#define _BITS_PTHREADTYPES_ARCH_H 1
#define __WORDSIZE 64
#define __WORDSIZE_TIME64_COMPAT32 1
#define __SYSCALL_WORDSIZE 64
#define __SIZEOF_PTHREAD_MUTEX_T 40
#define __SIZEOF_PTHREAD_ATTR_T 56
#define __SIZEOF_PTHREAD_RWLOCK_T 56
#define __SIZEOF_PTHREAD_BARRIER_T 32
#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
#define __SIZEOF_PTHREAD_COND_T 48
#define __SIZEOF_PTHREAD_CONDATTR_T 4
#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
#define __LOCK_ALIGNMENT
#define __ONCE_ALIGNMENT
#define _BITS_ATOMIC_WIDE_COUNTER_H
typedef union {
  __extension__ unsigned long long int __value64;
  struct {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
typedef struct __pthread_internal_list {
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
typedef struct __pthread_internal_slist {
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
#define _THREAD_MUTEX_INTERNAL_H 1
struct __pthread_mutex_s {
  int __lock;
  unsigned int __count;
  int __owner;
  unsigned int __nusers;
  int __kind;
  short __spins;
  short __elision;
  __pthread_list_t __list;
#define __PTHREAD_MUTEX_HAVE_PREV 1
};
#define __PTHREAD_MUTEX_INITIALIZER(__kind)                                    \
  0, 0, 0, 0, __kind, 0, 0, { NULL, NULL }
#define _RWLOCK_INTERNAL_H
struct __pthread_rwlock_arch_t {
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;
  int __cur_writer;
  int __shared;
  signed char __rwelision;
  unsigned char __pad1[7];
#define __PTHREAD_RWLOCK_ELISION_EXTRA 0, {0, 0, 0, 0, 0, 0, 0}
  unsigned long int __pad2;
  unsigned int __flags;
};
#define __PTHREAD_RWLOCK_INITIALIZER(__flags)                                  \
  0, 0, 0, 0, 0, 0, 0, 0, __PTHREAD_RWLOCK_ELISION_EXTRA, 0, __flags
struct __pthread_cond_s {
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
  unsigned int __unused_initialized_1;
  unsigned int __unused_initialized_2;
};
typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;
typedef struct {
  int __data;
} __once_flag;
#define __ONCE_FLAG_INIT {0}
typedef unsigned long int pthread_t;
typedef union {
  char __size[4];
  int __align;
} pthread_mutexattr_t;
typedef union {
  char __size[4];
  int __align;
} pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union pthread_attr_t {
  char __size[56];
  long int __align;
};
typedef union pthread_attr_t pthread_attr_t;
#define __have_pthread_attr_t 1
typedef union {
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;
typedef union {
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;
typedef union {
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;
typedef union {
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
typedef union {
  char __size[32];
  long int __align;
} pthread_barrier_t;
typedef union {
  char __size[4];
  int __align;
} pthread_barrierattr_t;

extern long int random(void) __attribute__((__nothrow__, __leaf__));
extern void srandom(unsigned int __seed) __attribute__((__nothrow__, __leaf__));
extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2)));
extern char *setstate(char *__statebuf) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
struct random_data {
  int32_t *fptr;
  int32_t *rptr;
  int32_t *state;
  int rand_type;
  int rand_deg;
  int rand_sep;
  int32_t *end_ptr;
};
extern int random_r(struct random_data *__restrict __buf,
                    int32_t *__restrict __result)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern int srandom_r(unsigned int __seed, struct random_data *__buf)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2)));
extern int initstate_r(unsigned int __seed, char *__restrict __statebuf,
                       size_t __statelen, struct random_data *__restrict __buf)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2, 4)));
extern int setstate_r(char *__restrict __statebuf,
                      struct random_data *__restrict __buf)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern int rand(void) __attribute__((__nothrow__, __leaf__));
extern void srand(unsigned int __seed) __attribute__((__nothrow__, __leaf__));
extern int rand_r(unsigned int *__seed) __attribute__((__nothrow__, __leaf__));
extern double drand48(void) __attribute__((__nothrow__, __leaf__));
extern double erand48(unsigned short int __xsubi[3])
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern long int lrand48(void) __attribute__((__nothrow__, __leaf__));
extern long int nrand48(unsigned short int __xsubi[3])
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern long int mrand48(void) __attribute__((__nothrow__, __leaf__));
extern long int jrand48(unsigned short int __xsubi[3])
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern void srand48(long int __seedval) __attribute__((__nothrow__, __leaf__));
extern unsigned short int *seed48(unsigned short int __seed16v[3])
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern void lcong48(unsigned short int __param[7])
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
struct drand48_data {
  unsigned short int __x[3];
  unsigned short int __old_x[3];
  unsigned short int __c;
  unsigned short int __init;
  __extension__ unsigned long long int __a;
};
extern int drand48_r(struct drand48_data *__restrict __buffer,
                     double *__restrict __result)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern int erand48_r(unsigned short int __xsubi[3],
                     struct drand48_data *__restrict __buffer,
                     double *__restrict __result)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern int lrand48_r(struct drand48_data *__restrict __buffer,
                     long int *__restrict __result)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern int nrand48_r(unsigned short int __xsubi[3],
                     struct drand48_data *__restrict __buffer,
                     long int *__restrict __result)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern int mrand48_r(struct drand48_data *__restrict __buffer,
                     long int *__restrict __result)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern int jrand48_r(unsigned short int __xsubi[3],
                     struct drand48_data *__restrict __buffer,
                     long int *__restrict __result)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern int srand48_r(long int __seedval, struct drand48_data *__buffer)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2)));
extern int seed48_r(unsigned short int __seed16v[3],
                    struct drand48_data *__buffer)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern int lcong48_r(unsigned short int __param[7],
                     struct drand48_data *__buffer)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern __uint32_t arc4random(void) __attribute__((__nothrow__, __leaf__));
extern void arc4random_buf(void *__buf, size_t __size)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
    __attribute__((__nothrow__, __leaf__));
extern void *malloc(size_t __size) __attribute__((__nothrow__, __leaf__))
__attribute__((__malloc__)) __attribute__((__alloc_size__(1)));
extern void *calloc(size_t __nmemb, size_t __size)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__malloc__))
    __attribute__((__alloc_size__(1, 2)));
extern void *realloc(void *__ptr, size_t __size)
    __attribute__((__nothrow__, __leaf__))
    __attribute__((__warn_unused_result__)) __attribute__((__alloc_size__(2)));
extern void free(void *__ptr) __attribute__((__nothrow__, __leaf__));
extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
    __attribute__((__nothrow__, __leaf__))
    __attribute__((__warn_unused_result__))
    __attribute__((__alloc_size__(2, 3)))
    __attribute__((__malloc__(__builtin_free, 1)));
extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
    __attribute__((__nothrow__, __leaf__))
    __attribute__((__malloc__(reallocarray, 1)));
#define _ALLOCA_H 1
#define __need_size_t
#undef __need_ptrdiff_t
#undef __need_size_t
#undef __need_wchar_t
#undef NULL
#define NULL ((void *)0)
#undef __need_NULL
#undef offsetof
#define offsetof(TYPE, MEMBER) __builtin_offsetof(TYPE, MEMBER)

#undef alloca
extern void *alloca(size_t __size) __attribute__((__nothrow__, __leaf__));
#define alloca(size) __builtin_alloca(size)

extern void *valloc(size_t __size) __attribute__((__nothrow__, __leaf__))
__attribute__((__malloc__)) __attribute__((__alloc_size__(1)));
extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern void *aligned_alloc(size_t __alignment, size_t __size)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__malloc__))
    __attribute__((__alloc_align__(1))) __attribute__((__alloc_size__(2)));
extern void abort(void) __attribute__((__nothrow__, __leaf__))
__attribute__((__noreturn__)) __attribute__((__cold__));
extern int atexit(void (*__func)(void)) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int at_quick_exit(void (*__func)(void))
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern int on_exit(void (*__func)(int __status, void *__arg), void *__arg)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern void exit(int __status) __attribute__((__nothrow__, __leaf__))
__attribute__((__noreturn__));
extern void quick_exit(int __status) __attribute__((__nothrow__, __leaf__))
__attribute__((__noreturn__));
extern void _Exit(int __status) __attribute__((__nothrow__, __leaf__))
__attribute__((__noreturn__));
extern char *getenv(const char *__name) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int putenv(char *__string) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int setenv(const char *__name, const char *__value, int __replace)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2)));
extern int unsetenv(const char *__name) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int clearenv(void) __attribute__((__nothrow__, __leaf__));
extern char *mktemp(char *__template) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int mkstemp(char *__template) __attribute__((__nonnull__(1)));
extern int mkstemps(char *__template, int __suffixlen)
    __attribute__((__nonnull__(1)));
extern char *mkdtemp(char *__template) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern int system(const char *__command);
extern char *realpath(const char *__restrict __name,
                      char *__restrict __resolved)
    __attribute__((__nothrow__, __leaf__));
#define __COMPAR_FN_T
typedef int (*__compar_fn_t)(const void *, const void *);
extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
                     size_t __size, __compar_fn_t __compar)
    __attribute__((__nonnull__(1, 2, 5)));
extern void qsort(void *__base, size_t __nmemb, size_t __size,
                  __compar_fn_t __compar) __attribute__((__nonnull__(1, 4)));
extern int abs(int __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern long int labs(long int __x) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
__extension__ extern long long int llabs(long long int __x)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern div_t div(int __numer, int __denom)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern ldiv_t ldiv(long int __numer, long int __denom)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
__extension__ extern lldiv_t lldiv(long long int __numer, long long int __denom)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt,
                  int *__restrict __sign) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(3, 4)));
extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt,
                  int *__restrict __sign) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(3, 4)));
extern char *gcvt(double __value, int __ndigit, char *__buf)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(3)));
extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(3, 4)));
extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(3, 4)));
extern char *qgcvt(long double __value, int __ndigit, char *__buf)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(3)));
extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt,
                  int *__restrict __sign, char *__restrict __buf, size_t __len)
    __attribute__((__nothrow__, __leaf__))
    __attribute__((__nonnull__(3, 4, 5)));
extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt,
                  int *__restrict __sign, char *__restrict __buf, size_t __len)
    __attribute__((__nothrow__, __leaf__))
    __attribute__((__nonnull__(3, 4, 5)));
extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign, char *__restrict __buf, size_t __len)
    __attribute__((__nothrow__, __leaf__))
    __attribute__((__nonnull__(3, 4, 5)));
extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign, char *__restrict __buf, size_t __len)
    __attribute__((__nothrow__, __leaf__))
    __attribute__((__nonnull__(3, 4, 5)));
extern int mblen(const char *__s, size_t __n)
    __attribute__((__nothrow__, __leaf__));
extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s,
                  size_t __n) __attribute__((__nothrow__, __leaf__));
extern int wctomb(char *__s, wchar_t __wchar)
    __attribute__((__nothrow__, __leaf__));
extern size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s,
                       size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__access__(__read_only__, 2)));
extern size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs,
                       size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__access__(__write_only__, 1, 3)))
__attribute__((__access__(__read_only__, 2)));
extern int rpmatch(const char *__response)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern int getsubopt(char **__restrict __optionp,
                     char *const *__restrict __tokens,
                     char **__restrict __valuep)
    __attribute__((__nothrow__, __leaf__))
    __attribute__((__nonnull__(1, 2, 3)));
extern int getloadavg(double __loadavg[], int __nelem)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));

#define CR_CFG_NUM_DOUBLE 0
#define CR_CFG_NO_MULTITHREAD 0
#define CR_CFG_NO_LOCK 0
#define _OMP_H 1
#define __GOMP_DEPRECATED_5_0
#define __GOMP_DEPRECATED_5_1
#define _LIBGOMP_OMP_LOCK_DEFINED 1
typedef struct {
  unsigned char _x[4] __attribute__((__aligned__(4)));
} omp_lock_t;
typedef struct {
  unsigned char _x[16] __attribute__((__aligned__(8)));
} omp_nest_lock_t;
typedef enum omp_sched_t {
  omp_sched_static = 1,
  omp_sched_dynamic = 2,
  omp_sched_guided = 3,
  omp_sched_auto = 4,
  omp_sched_monotonic = 0x80000000U
} omp_sched_t;
typedef enum omp_proc_bind_t {
  omp_proc_bind_false = 0,
  omp_proc_bind_true = 1,
  omp_proc_bind_primary = 2,
  omp_proc_bind_master = omp_proc_bind_primary,
  omp_proc_bind_close = 3,
  omp_proc_bind_spread = 4
} omp_proc_bind_t;
typedef enum omp_sync_hint_t {
  omp_sync_hint_none = 0,
  omp_lock_hint_none = omp_sync_hint_none,
  omp_sync_hint_uncontended = 1,
  omp_lock_hint_uncontended = omp_sync_hint_uncontended,
  omp_sync_hint_contended = 2,
  omp_lock_hint_contended = omp_sync_hint_contended,
  omp_sync_hint_nonspeculative = 4,
  omp_lock_hint_nonspeculative = omp_sync_hint_nonspeculative,
  omp_sync_hint_speculative = 8,
  omp_lock_hint_speculative = omp_sync_hint_speculative
} omp_sync_hint_t;
typedef omp_sync_hint_t omp_lock_hint_t;
typedef struct __attribute__((__aligned__(sizeof(void *)))) omp_depend_t {
  char __omp_depend_t__[2 * sizeof(void *)];
} omp_depend_t;
typedef enum omp_pause_resource_t {
  omp_pause_soft = 1,
  omp_pause_hard = 2
} omp_pause_resource_t;
typedef long int omp_intptr_t;
typedef long unsigned int omp_uintptr_t;
#define __GOMP_UINTPTR_T_ENUM
typedef enum omp_memspace_handle_t {
  omp_default_mem_space = 0,
  omp_large_cap_mem_space = 1,
  omp_const_mem_space = 2,
  omp_high_bw_mem_space = 3,
  omp_low_lat_mem_space = 4,
  __omp_memspace_handle_t_max__ = 0xffffffffffffffffUL
} omp_memspace_handle_t;
typedef enum omp_allocator_handle_t {
  omp_null_allocator = 0,
  omp_default_mem_alloc = 1,
  omp_large_cap_mem_alloc = 2,
  omp_const_mem_alloc = 3,
  omp_high_bw_mem_alloc = 4,
  omp_low_lat_mem_alloc = 5,
  omp_cgroup_mem_alloc = 6,
  omp_pteam_mem_alloc = 7,
  omp_thread_mem_alloc = 8,
  ompx_gnu_pinned_mem_alloc = 200,
  __omp_allocator_handle_t_max__ = 0xffffffffffffffffUL
} omp_allocator_handle_t;
typedef enum omp_alloctrait_key_t {
  omp_atk_sync_hint = 1,
  omp_atk_alignment = 2,
  omp_atk_access = 3,
  omp_atk_pool_size = 4,
  omp_atk_fallback = 5,
  omp_atk_fb_data = 6,
  omp_atk_pinned = 7,
  omp_atk_partition = 8
} omp_alloctrait_key_t;
typedef enum omp_alloctrait_value_t {
  omp_atv_default = (long unsigned int)-1,
  omp_atv_false = 0,
  omp_atv_true = 1,
  omp_atv_contended = 3,
  omp_atv_uncontended = 4,
  omp_atv_serialized = 5,
  omp_atv_sequential = omp_atv_serialized,
  omp_atv_private = 6,
  omp_atv_all = 7,
  omp_atv_thread = 8,
  omp_atv_pteam = 9,
  omp_atv_cgroup = 10,
  omp_atv_default_mem_fb = 11,
  omp_atv_null_fb = 12,
  omp_atv_abort_fb = 13,
  omp_atv_allocator_fb = 14,
  omp_atv_environment = 15,
  omp_atv_nearest = 16,
  omp_atv_blocked = 17,
  omp_atv_interleaved = 18
} omp_alloctrait_value_t;
typedef struct omp_alloctrait_t {
  omp_alloctrait_key_t key;
  omp_uintptr_t value;
} omp_alloctrait_t;
typedef enum omp_event_handle_t {
  __omp_event_handle_t_max__ = 0xffffffffffffffffUL
} omp_event_handle_t;
enum { omp_initial_device = -1, omp_invalid_device = -4 };
typedef enum omp_interop_t {
  omp_interop_none = 0,
  __omp_interop_t_max__ = 0xffffffffffffffffUL
} omp_interop_t;
typedef enum omp_interop_fr_t {
  omp_ifr_cuda = 1,
  omp_ifr_cuda_driver = 2,
  omp_ifr_opencl = 3,
  omp_ifr_sycl = 4,
  omp_ifr_hip = 5,
  omp_ifr_level_zero = 6,
  omp_ifr_hsa = 7,
  omp_ifr_last = omp_ifr_hsa
} omp_interop_fr_t;
typedef enum omp_interop_property_t {
  omp_ipr_fr_id = -1,
  omp_ipr_fr_name = -2,
  omp_ipr_vendor = -3,
  omp_ipr_vendor_name = -4,
  omp_ipr_device_num = -5,
  omp_ipr_platform = -6,
  omp_ipr_device = -7,
  omp_ipr_device_context = -8,
  omp_ipr_targetsync = -9,
  omp_ipr_first = -9
} omp_interop_property_t;
typedef enum omp_interop_rc_t {
  omp_irc_no_value = 1,
  omp_irc_success = 0,
  omp_irc_empty = -1,
  omp_irc_out_of_range = -2,
  omp_irc_type_int = -3,
  omp_irc_type_ptr = -4,
  omp_irc_type_str = -5,
  omp_irc_other = -6
} omp_interop_rc_t;
#define __GOMP_NOTHROW __attribute__((__nothrow__))
#define __GOMP_DEFAULT_NULL_ALLOCATOR
#define __GOMP_DEFAULT_NULL
extern void omp_set_num_threads(int) __attribute__((__nothrow__));
extern int omp_get_num_threads(void) __attribute__((__nothrow__));
extern int omp_get_max_threads(void) __attribute__((__nothrow__));
extern int omp_get_thread_num(void) __attribute__((__nothrow__));
extern int omp_get_num_procs(void) __attribute__((__nothrow__));
extern int omp_in_parallel(void) __attribute__((__nothrow__));
extern void omp_set_dynamic(int) __attribute__((__nothrow__));
extern int omp_get_dynamic(void) __attribute__((__nothrow__));
extern void omp_set_nested(int) __attribute__((__nothrow__));
extern int omp_get_nested(void) __attribute__((__nothrow__));
extern void omp_init_lock(omp_lock_t *) __attribute__((__nothrow__));
extern void omp_init_lock_with_hint(omp_lock_t *, omp_sync_hint_t)
    __attribute__((__nothrow__));
extern void omp_destroy_lock(omp_lock_t *) __attribute__((__nothrow__));
extern void omp_set_lock(omp_lock_t *) __attribute__((__nothrow__));
extern void omp_unset_lock(omp_lock_t *) __attribute__((__nothrow__));
extern int omp_test_lock(omp_lock_t *) __attribute__((__nothrow__));
extern void omp_init_nest_lock(omp_nest_lock_t *) __attribute__((__nothrow__));
extern void omp_init_nest_lock_with_hint(omp_nest_lock_t *, omp_sync_hint_t)
    __attribute__((__nothrow__));
extern void omp_destroy_nest_lock(omp_nest_lock_t *)
    __attribute__((__nothrow__));
extern void omp_set_nest_lock(omp_nest_lock_t *) __attribute__((__nothrow__));
extern void omp_unset_nest_lock(omp_nest_lock_t *) __attribute__((__nothrow__));
extern int omp_test_nest_lock(omp_nest_lock_t *) __attribute__((__nothrow__));
extern double omp_get_wtime(void) __attribute__((__nothrow__));
extern double omp_get_wtick(void) __attribute__((__nothrow__));
extern void omp_set_schedule(omp_sched_t, int) __attribute__((__nothrow__));
extern void omp_get_schedule(omp_sched_t *, int *) __attribute__((__nothrow__));
extern int omp_get_thread_limit(void) __attribute__((__nothrow__));
extern void omp_set_max_active_levels(int) __attribute__((__nothrow__));
extern int omp_get_max_active_levels(void) __attribute__((__nothrow__));
extern int omp_get_supported_active_levels(void) __attribute__((__nothrow__));
extern int omp_get_level(void) __attribute__((__nothrow__));
extern int omp_get_ancestor_thread_num(int) __attribute__((__nothrow__));
extern int omp_get_team_size(int) __attribute__((__nothrow__));
extern int omp_get_active_level(void) __attribute__((__nothrow__));
extern int omp_in_final(void) __attribute__((__nothrow__));
extern int omp_in_explicit_task(void) __attribute__((__nothrow__));
extern int omp_get_cancellation(void) __attribute__((__nothrow__));
extern omp_proc_bind_t omp_get_proc_bind(void) __attribute__((__nothrow__));
extern int omp_get_num_places(void) __attribute__((__nothrow__));
extern int omp_get_place_num_procs(int) __attribute__((__nothrow__));
extern void omp_get_place_proc_ids(int, int *) __attribute__((__nothrow__));
extern int omp_get_place_num(void) __attribute__((__nothrow__));
extern int omp_get_partition_num_places(void) __attribute__((__nothrow__));
extern void omp_get_partition_place_nums(int *) __attribute__((__nothrow__));
extern void omp_set_default_device(int) __attribute__((__nothrow__));
extern int omp_get_default_device(void) __attribute__((__nothrow__));
extern int omp_get_num_devices(void) __attribute__((__nothrow__));
extern int omp_get_device_num(void) __attribute__((__nothrow__));
extern int omp_get_num_teams(void) __attribute__((__nothrow__));
extern int omp_get_team_num(void) __attribute__((__nothrow__));
extern int omp_is_initial_device(void) __attribute__((__nothrow__));
extern int omp_get_initial_device(void) __attribute__((__nothrow__));
extern int omp_get_max_task_priority(void) __attribute__((__nothrow__));
extern void omp_fulfill_event(omp_event_handle_t) __attribute__((__nothrow__));
extern void omp_set_num_teams(int) __attribute__((__nothrow__));
extern int omp_get_max_teams(void) __attribute__((__nothrow__));
extern void omp_set_teams_thread_limit(int) __attribute__((__nothrow__));
extern int omp_get_teams_thread_limit(void) __attribute__((__nothrow__));
extern void *omp_target_alloc(long unsigned int, int)
    __attribute__((__nothrow__));
extern void omp_target_free(void *, int) __attribute__((__nothrow__));
extern int omp_target_is_present(const void *, int)
    __attribute__((__nothrow__));
extern int omp_target_memcpy(void *, const void *, long unsigned int,
                             long unsigned int, long unsigned int, int, int)
    __attribute__((__nothrow__));
extern int omp_target_memcpy_async(void *, const void *, long unsigned int,
                                   long unsigned int, long unsigned int, int,
                                   int, int, omp_depend_t *)
    __attribute__((__nothrow__));
extern int
omp_target_memcpy_rect(void *, const void *, long unsigned int, int,
                       const long unsigned int *, const long unsigned int *,
                       const long unsigned int *, const long unsigned int *,
                       const long unsigned int *, int, int)
    __attribute__((__nothrow__));
extern int omp_target_memcpy_rect_async(
    void *, const void *, long unsigned int, int, const long unsigned int *,
    const long unsigned int *, const long unsigned int *,
    const long unsigned int *, const long unsigned int *, int, int, int,
    omp_depend_t *) __attribute__((__nothrow__));
extern int omp_target_associate_ptr(const void *, const void *,
                                    long unsigned int, long unsigned int, int)
    __attribute__((__nothrow__));
extern int omp_target_disassociate_ptr(const void *, int)
    __attribute__((__nothrow__));
extern void *omp_get_mapped_ptr(const void *, int) __attribute__((__nothrow__));
extern int omp_target_is_accessible(const void *, long unsigned int, int)
    __attribute__((__nothrow__));
extern void omp_set_affinity_format(const char *) __attribute__((__nothrow__));
extern long unsigned int omp_get_affinity_format(char *, long unsigned int)
    __attribute__((__nothrow__));
extern void omp_display_affinity(const char *) __attribute__((__nothrow__));
extern long unsigned int omp_capture_affinity(char *, long unsigned int,
                                              const char *)
    __attribute__((__nothrow__));
extern int omp_pause_resource(omp_pause_resource_t, int)
    __attribute__((__nothrow__));
extern int omp_pause_resource_all(omp_pause_resource_t)
    __attribute__((__nothrow__));
extern omp_allocator_handle_t omp_init_allocator(omp_memspace_handle_t, int,
                                                 const omp_alloctrait_t[])
    __attribute__((__nothrow__));
extern void omp_destroy_allocator(omp_allocator_handle_t)
    __attribute__((__nothrow__));
extern void omp_set_default_allocator(omp_allocator_handle_t)
    __attribute__((__nothrow__));
extern omp_allocator_handle_t omp_get_default_allocator(void)
    __attribute__((__nothrow__));
extern void omp_free(void *, omp_allocator_handle_t)
    __attribute__((__nothrow__));
extern void *omp_alloc(long unsigned int, omp_allocator_handle_t)
    __attribute__((__nothrow__))
    __attribute__((__malloc__, __malloc__(omp_free), __alloc_size__(1)));
extern void *omp_aligned_alloc(long unsigned int, long unsigned int,
                               omp_allocator_handle_t)
    __attribute__((__nothrow__))
    __attribute__((__malloc__, __malloc__(omp_free), __alloc_size__(2),
                   __alloc_align__(1)));
extern void *omp_calloc(long unsigned int, long unsigned int,
                        omp_allocator_handle_t) __attribute__((__nothrow__))
__attribute__((__malloc__, __malloc__(omp_free), __alloc_size__(1, 2)));
extern void *omp_aligned_calloc(long unsigned int, long unsigned int,
                                long unsigned int, omp_allocator_handle_t)
    __attribute__((__nothrow__))
    __attribute__((__malloc__, __malloc__(omp_free), __alloc_size__(2, 3),
                   __alloc_align__(1)));
extern void *omp_realloc(void *, long unsigned int, omp_allocator_handle_t,
                         omp_allocator_handle_t) __attribute__((__nothrow__))
__attribute__((__malloc__(omp_free), __alloc_size__(2)));
extern void omp_display_env(int) __attribute__((__nothrow__));
extern int omp_get_num_interop_properties(const omp_interop_t)
    __attribute__((__nothrow__));
extern omp_intptr_t omp_get_interop_int(const omp_interop_t,
                                        omp_interop_property_t,
                                        omp_interop_rc_t *)
    __attribute__((__nothrow__));
extern void *omp_get_interop_ptr(const omp_interop_t, omp_interop_property_t,
                                 omp_interop_rc_t *)
    __attribute__((__nothrow__));
extern const char *omp_get_interop_str(const omp_interop_t,
                                       omp_interop_property_t,
                                       omp_interop_rc_t *)
    __attribute__((__nothrow__));
extern const char *omp_get_interop_name(const omp_interop_t,
                                        omp_interop_property_t)
    __attribute__((__nothrow__));
extern const char *omp_get_interop_type_desc(const omp_interop_t,
                                             omp_interop_property_t)
    __attribute__((__nothrow__));
extern const char *omp_get_interop_rc_desc(const omp_interop_t,
                                           omp_interop_rc_t)
    __attribute__((__nothrow__));
extern int omp_get_device_from_uid(const char *) __attribute__((__nothrow__));
extern const char *omp_get_uid_from_device(int) __attribute__((__nothrow__));
#define CR_IFOMP(B) B
#define CR_IFOMPLOCK(B) B
#define cr_num float
#define cr_NUM_FMT "%f"
#define cr_NUM_INT_TYPE int32_t
#define cr_NUM_INT_CAST(a, b) memcpy(&b, &a, sizeof(cr_NUM_INT_TYPE))
#define cr_ABORT(t, fmt, ...)                                                  \
  do {                                                                         \
    fprintf(stderr, "%s:%d [%s]" fmt "\n", __FILE__, __LINE__, t,              \
            ##__VA_ARGS__);                                                    \
    abort();                                                                   \
  } while (0)
#define cr_UNREACHABLE(fmt, ...) cr_ABORT("Unreachable", fmt, ##__VA_ARGS__)
#define cr_ERROR(fmt, ...) cr_ABORT("Error", fmt, ##__VA_ARGS__)
#define cr_ASSERT(a, fmt, ...)                                                 \
  if (!(a))                                                                    \
    cr_ABORT("Assertion `" #a "` failed", fmt, ##__VA_ARGS__);
#define cr_EPSILON 1e-2
#define cr_VIEWPORT_DEPTH 255
#define cr_AMBIENT 0
#define cr_SCHEDULE dynamic
#define cr_Vec3_ADD_INPLACE(a, b)                                              \
  a.x += b.x;                                                                  \
  a.y += b.y;                                                                  \
  a.z += b.z
#define cr_Vec3_NEG_INPLACE(a)                                                 \
  a.x = -a.x;                                                                  \
  a.y = -a.y;                                                                  \
  a.z = -a.z
#define cr_ENTITIES_INITIAL_CAPACITY 8
#define _cr_Texture_draw_face_NAME(SHADING_MODE, SAMPLING_MODE,                \
                                   HAS_NORMAL_MAP)                             \
  _cr_Texture_draw_face_##SHADING_MODE##_##SAMPLING_MODE##_##HAS_NORMAL_MAP
#define _cr_Texture_draw_face_ARGS                                             \
  (cr_Linear_Texture texture, int width, int height, cr_Face *face,            \
   cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,                \
   cr_Texture *specular_map, cr_num *zbuffer, omp_lock_t *zbuffer_locks,       \
   cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,          \
   cr_Matrix inverse_transform, cr_num near_plane)
#define _cr_Texture_draw_face_DECL(SHADING_MODE, SAMPLING_MODE,                \
                                   HAS_NORMAL_MAP)                             \
  bool _cr_Texture_draw_face_NAME(SHADING_MODE, SAMPLING_MODE, HAS_NORMAL_MAP) \
      _cr_Texture_draw_face_ARGS
#define _cr_Texture_draw_face_DECLH(...)                                       \
  _cr_Texture_draw_face_DECL(__VA_ARGS__);
#define _cr_Texture_draw_face_FORALL1(XMACRO) XMACRO(GOURAUD) XMACRO(PHONG)
#define _cr_Texture_draw_face_FORALL2(XMACRO)                                  \
  XMACRO(FLOOR) XMACRO(CLOSEST) XMACRO(LINEAR)
#define _cr_Texture_draw_face_FORALL3(XMACRO) XMACRO(0) XMACRO(1)
#define _cr_Texture_draw_face_FORALL(XMACRO)                                   \
  XMACRO(GOURAUD, FLOOR, 0)                                                    \
  XMACRO(GOURAUD, FLOOR, 1)                                                    \
  XMACRO(GOURAUD, CLOSEST, 0) XMACRO(GOURAUD, CLOSEST, 1)                      \
      XMACRO(GOURAUD, LINEAR, 0) XMACRO(GOURAUD, LINEAR, 1)                    \
          XMACRO(PHONG, FLOOR, 0) XMACRO(PHONG, FLOOR, 1)                      \
              XMACRO(PHONG, CLOSEST, 0) XMACRO(PHONG, CLOSEST, 1)              \
                  XMACRO(PHONG, LINEAR, 0) XMACRO(PHONG, LINEAR, 1)
#define _cr_Texture_draw_face_HANDLE(SHADING, SAMPLING, NORMAL)                \
  return _cr_Texture_draw_face_NAME(SHADING, SAMPLING, NORMAL);
#define _cr_Texture_draw_face_NORMAL_CASES(SHADING, SAMPLING)                  \
  if (has_normal_map) {                                                        \
    _cr_Texture_draw_face_HANDLE(SHADING, SAMPLING, 1)                         \
  } else {                                                                     \
    _cr_Texture_draw_face_HANDLE(SHADING, SAMPLING, 0)                         \
  }
#define _cr_Texture_draw_face_SAMPLING_CASES(SHADING)                          \
  case FLOOR:                                                                  \
    _cr_Texture_draw_face_NORMAL_CASES(SHADING, FLOOR);                        \
    break;                                                                     \
  case CLOSEST:                                                                \
    _cr_Texture_draw_face_NORMAL_CASES(SHADING, CLOSEST);                      \
    break;                                                                     \
  case LINEAR:                                                                 \
    _cr_Texture_draw_face_NORMAL_CASES(SHADING, LINEAR);                       \
    break;
#define _cr_Texture_draw_face_SHADING_CASES                                    \
  case GOURAUD:                                                                \
    switch (sampling_mode) { _cr_Texture_draw_face_SAMPLING_CASES(GOURAUD) }   \
    break;                                                                     \
  case PHONG:                                                                  \
    switch (sampling_mode) { _cr_Texture_draw_face_SAMPLING_CASES(PHONG) }     \
    break;
#define _cr_Texture_draw_face_SELECT                                           \
  switch (shading_mode) { _cr_Texture_draw_face_SHADING_CASES }                \
  return false;
#define CR_CFG_ABI_TAG ((CR_CFG_NUM_DOUBLE) | (CR_CFG_NO_MULTITHREAD << 1))
#define cr_INIT_CRENDER(...)                                                   \
  cr_ASSERT(_cr_abi_tag == CR_CFG_ABI_TAG,                                     \
            ": please recompile libcrender with correct crender_cfg.h!");      \
  cr_crender_initted = true;
#define cr_REQUIRE_INIT                                                        \
  cr_ASSERT(cr_crender_initted,                                                \
            ": crender not initted! use the macro cr_INIT_CRENDER().");
#define cr_DYNARR_BASE_CAPACITY 8
#define cr_DYNARR_PUSH(arr, what)                                              \
  do {                                                                         \
    if ((arr)->count + 1 > (arr)->capacity) {                                  \
      if ((arr)->capacity == 0) {                                              \
        (arr)->capacity = cr_DYNARR_BASE_CAPACITY;                             \
      } else {                                                                 \
        (arr)->capacity *= 2;                                                  \
      }                                                                        \
      (arr)->items =                                                           \
          realloc((arr)->items, (arr)->capacity * sizeof(*(arr)->items));      \
      cr_ASSERT((arr)->items != NULL, "")                                      \
    }                                                                          \
    (arr)->items[(arr)->count++] = what;                                       \
  } while (0)
#define cr_DYNARR_REMOVE_SWAP_LAST(arr, index)                                 \
  do {                                                                         \
    cr_ASSERT((index) < (arr)->count, ": remove index out of range");          \
    (arr)->items[index] = (arr)->items[--(arr)->count];                        \
  } while (0)
#define cr_DYNARR_REMOVE_KEEP_ORDER(arr, index)                                \
  do {                                                                         \
    cr_ASSERT((index) < (arr)->count, ": remove index out of range");          \
    if (index < (arr)->count - 1) {                                            \
      memmove(&(arr)->items[index], &(arr)->items[index + 1],                  \
              ((arr)->count - 1 - index) * sizeof(*(arr)->items));             \
    }                                                                          \
    (arr)->count--;                                                            \
  } while (0)
#define cr_DYNARR_DEALLOC(arr) free(arr.items)
extern int _cr_abi_tag;
extern bool cr_crender_initted;
typedef enum cr_ShadingMode {
  PHONG = 0,
  GOURAUD = 1,
} cr_ShadingMode;
typedef enum cr_SamplingMode {
  FLOOR = 0,
  CLOSEST = 1,
  LINEAR = 2,
} cr_SamplingMode;
typedef struct cr_Vec2 {
  float x;
  float y;
} cr_Vec2;
typedef struct cr_Vec3 {
  float x;
  float y;
  float z;
} cr_Vec3;
typedef struct cr_Vec4 {
  float x, y, z, w;
} cr_Vec4;
typedef struct cr_Matrix {
  float **m;
  int rows;
  int cols;
  bool valid;
} cr_Matrix;
static inline float cr_clamp(float a, float lo, float hi) {
  return fminf(fmaxf(a, lo), hi);
}
static inline cr_Vec2 cr_Vec2_create(float x, float y) {
  return (cr_Vec2){x, y};
}
static inline cr_Vec3 cr_Vec3_create(float x, float y, float z) {
  return (cr_Vec3){x, y, z};
}
static inline cr_Vec3 cr_Vec3_cross(cr_Vec3 v1, cr_Vec3 v2) {
  return cr_Vec3_create(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z,
                        v1.x * v2.y - v1.y * v2.x);
}
static inline float cr_Vec3_dot(cr_Vec3 v1, cr_Vec3 v2) {
  return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
}
static inline cr_Vec3 cr_Vec3_add(cr_Vec3 v1, cr_Vec3 v2) {
  return cr_Vec3_create(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
}
static inline cr_Vec3 cr_Vec3_neg(cr_Vec3 v1) {
  return cr_Vec3_create(-v1.x, -v1.y, -v1.z);
}
static inline cr_Vec3 cr_Vec3_sub(cr_Vec3 v1, cr_Vec3 v2) {
  return cr_Vec3_create(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
}
static inline cr_Vec3 cr_Vec3_mul(cr_Vec3 v1, float a) {
  return cr_Vec3_create(v1.x * a, v1.y * a, v1.z * a);
}
static inline cr_Vec3 cr_Vec3_div(cr_Vec3 v1, float a) {
  return cr_Vec3_create(v1.x / a, v1.y / a, v1.z / a);
}
static inline float cr_Vec3_length(cr_Vec3 v) {
  return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}
static inline cr_Vec3 cr_Vec3_normalized(cr_Vec3 v) {
  return cr_Vec3_div(v, cr_Vec3_length(v));
}
static inline cr_Vec3 cr_Vec3_from_matrix(cr_Matrix mat) {
  return cr_Vec3_create(mat.m[0][0] / mat.m[3][0], mat.m[1][0] / mat.m[3][0],
                        mat.m[2][0] / mat.m[3][0]);
}
static inline cr_Vec3 cr_Vec3_from_matrix3(cr_Matrix mat) {
  return cr_Vec3_create(mat.m[0][0], mat.m[1][0], mat.m[2][0]);
}
static inline uint32_t cr__pack(int r, int g, int b) {
  return 0xff | b << 8 | g << 16 | r << 24;
}
static inline uint32_t cr_Vec3_phong(cr_Vec3 v1, float a, float lo, float hi) {
  return cr__pack(cr_clamp(v1.x * a + 0, lo, hi),
                  cr_clamp(v1.y * a + 0, lo, hi),
                  cr_clamp(v1.z * a + 0, lo, hi));
}
static inline uint32_t cr_Vec3_pack_color(cr_Vec3 v) {
  return cr__pack(v.x, v.y, v.z);
}
static inline cr_Vec3 cr_Vec3_normal_from_color(cr_Vec3 color) {
  return (cr_Vec3){-(color.x / (float)127.5) + 1, -(color.y / (float)127.5) + 1,
                   -(color.z / (float)127.5) + 1};
}
static inline void cr_Vec3_normalize(cr_Vec3 *v) {
  float l = cr_Vec3_length(*v);
  v->x /= l;
  v->y /= l;
  v->z /= l;
}
cr_Vec3 cr_Vec3_transform_dir(cr_Vec3 v, cr_Matrix mat);
void cr_Matrix_print(cr_Matrix m);
cr_Matrix cr_Matrix_empty(int rows, int cols);
cr_Matrix cr_Matrix_identity(int size);
cr_Matrix cr_Matrix_matmul(cr_Matrix m1, cr_Matrix m2);
cr_Matrix cr_Matrix_projection(float camz, float fov, float aspect);
cr_Matrix cr_Matrix_viewport(float x, float y, float w, float h, float d);
cr_Matrix cr_Matrix_from_vector(cr_Vec3 v);
cr_Matrix cr_Matrix_rotz(float theta);
cr_Matrix cr_Matrix_roty(float theta);
cr_Matrix cr_Matrix_rotx(float theta);
cr_Matrix cr_Matrix_inverse(cr_Matrix matrix);
cr_Matrix cr_Matrix_translation(cr_Vec3 v);
cr_Matrix cr_Matrix_rotation(cr_Vec3 v);
cr_Matrix cr_Matrix_inverse_clean(cr_Matrix matrix);
cr_Matrix cr_Matrix_clone(cr_Matrix m);
void cr_Matrix_dealloc(cr_Matrix *mat);
cr_Vec3 cr_Vec3_copy(cr_Vec3 v);
cr_Vec3 cr_Vec3_transform(cr_Vec3 v, cr_Matrix mat);
cr_Vec3 cr_Vec3_transform3(cr_Vec3 v, cr_Matrix mat);
void cr_Vec3_set_item(cr_Vec3 v, int i, float a);
float cr_Vec3_get_item(cr_Vec3 v, int i);
cr_Vec4 cr_Vec4_transform(cr_Vec3 v, cr_Matrix m);
typedef struct cr_Face {
  int vs[3];
  int vts[3];
  int vns[3];
} cr_Face;
typedef struct cr_Vec3_dynarr {
  cr_Vec3 *items;
  size_t count;
  size_t capacity;
} cr_Vec3_dynarr;
typedef struct cr_Face_dynarr {
  cr_Face *items;
  size_t count;
  size_t capacity;
} cr_Face_dynarr;
typedef struct cr_Object {
  cr_Vec3_dynarr vertices;
  cr_Vec3_dynarr uvs;
  cr_Vec3_dynarr normals;
  cr_Face_dynarr faces;
  bool valid;
} cr_Object;
typedef enum cr_FaceTriType {
  VERTEX = 0,
  UV = 1,
  NORMAL = 2,
} cr_FaceTriType;
cr_Object cr_Object_new();
void cr_Object_add_vertex(cr_Object *object, cr_Vec3 vertex);
void cr_Object_add_uv(cr_Object *object, cr_Vec3 uv);
void cr_Object_add_normal(cr_Object *object, cr_Vec3 normal);
void cr_Object_add_face(cr_Object *object, cr_Face face);
void cr_Object_dealloc(cr_Object *object);
cr_Object cr_Object_fromOBJ(char *fn);
typedef struct cr_Triangle {
  cr_Vec3 v0;
  cr_Vec3 v1;
  cr_Vec3 v2;
} cr_Triangle;
cr_Triangle cr_Triangle_transform(cr_Triangle tri, cr_Matrix transform);
cr_Triangle cr_Triangle_transform3(cr_Triangle tri, cr_Matrix transform);
cr_Triangle cr_Triangle_transform4(cr_Triangle tri, cr_Matrix transform,
                                   cr_Vec3 *ws);
cr_Triangle cr_Triangle_create(cr_Vec3 v0, cr_Vec3 v1, cr_Vec3 v2);
bool cr_Face_gettri(cr_Face *face, cr_Object *obj, cr_FaceTriType tt,
                    cr_Triangle *tri);
typedef struct cr_Texture {
  cr_Vec3 *m;
  int width;
  int height;
  bool valid;
} cr_Texture;
typedef uint32_t *cr_Linear_Texture;
cr_Texture cr_Texture_create(int width, int height, cr_Vec3 color);
cr_Texture cr_Texture_readPPM(char *fn);
cr_Texture cr_Texture_readPAM(char *fn);
cr_Texture cr_Texture_read(char *fn);
void cr_Texture_writePPM(cr_Texture texture, char *fn);
void cr_Texture_dealloc(cr_Texture *texture);
cr_Linear_Texture cr_Texture_to_linear(cr_Texture texture);
static inline cr_Vec3 cr_trinterpolate(cr_Triangle tri, cr_Vec3 bary) {
  float bx = bary.x, by = bary.y, bz = bary.z;
  return (cr_Vec3){tri.v0.x * bx + tri.v1.x * by + tri.v2.x * bz,
                   tri.v0.y * bx + tri.v1.y * by + tri.v2.y * bz,
                   tri.v0.z * bx + tri.v1.z * by + tri.v2.z * bz};
}
static inline cr_Vec3 cr_barycentric(cr_Vec3 v0, cr_Vec3 v1, cr_Vec3 v2,
                                     float px, float py, float denom) {
  float x0 = v0.x, y0 = v0.y;
  float x1 = v1.x, y1 = v1.y;
  float x2 = v2.x, y2 = v2.y;
  if (fabs(denom) < 1e-12) {
    return (cr_Vec3){-1.0, 1.0, 1.0};
  }
  float w1 = ((x2 - x0) * (py - y0) - (y2 - y0) * (px - x0)) * denom;
  float w2 = ((y1 - y0) * (px - x0) - (x1 - x0) * (py - y0)) * denom;
  return (cr_Vec3){(float)1.0 - w1 - w2, w1, w2};
}
static inline float cr_fmin3(float x, float y, float z) {
  return fmin(x, fmin(y, z));
}
static inline float cr_fmax3(float x, float y, float z) {
  return fmax(x, fmax(y, z));
}
typedef enum cr_TextureSetIndex {
  cr_TextureSetIndex_diffuse = 0,
  cr_TextureSetIndex_normal_map = 1,
  cr_TextureSetIndex_specular_map = 2,
  cr_TextureSetIndex_max = 3
} cr_TextureSetIndex;
typedef union cr_TextureSet {
  struct {
    cr_Texture *diffuse;
    cr_Texture *normal_map;
    cr_Texture *specular_map;
  };
  cr_Texture *textures[cr_TextureSetIndex_max];
} cr_TextureSet;
typedef struct cr_Entity {
  cr_Object *ob;
  cr_Matrix transform;
  cr_Matrix inverse_transform;
  cr_TextureSet ts;
  bool valid;
} cr_Entity;
typedef struct cr_SceneSettings {
  cr_ShadingMode shading_mode;
  cr_SamplingMode sampling_mode;
  size_t render_width;
  size_t render_height;
  float render_depth;
  float cam_z;
  float fov;
  float near_plane;
  cr_Vec3 light_dir;
  bool use_normal_map;
} cr_SceneSettings;
typedef struct cr_Entities {
  size_t count;
  size_t capacity;
  cr_Entity **items;
} cr_Entities;
typedef struct cr_Scene {
  cr_SceneSettings settings;
  cr_SceneSettings __internal_settings_cache;
  cr_Entities entities;
  size_t buffer_size;
  cr_Linear_Texture framebuffer;
  float *zbuffer;
  omp_lock_t *zbuffer_locks;
  cr_Matrix projection;
  cr_Matrix viewport;
  cr_Matrix world_transform;
  cr_Matrix inverse_world_transform;
  bool valid;
} cr_Scene;
cr_Entity cr_Entity_create(cr_Object *ob);
void cr_Entity_dealloc(cr_Entity *e);
void cr_Entity_detach_texture(cr_Entity *e, size_t index);
void cr_Entity_attach_texture(cr_Entity *e, size_t index, cr_Texture *texture);
void cr_Entity_set_transform(cr_Entity *e, cr_Matrix transform);
void cr_Entity_reset_transform(cr_Entity *e);
void cr_Entity_add_transform(cr_Entity *e, cr_Matrix transform);
void cr_Entity_translate(cr_Entity *e, cr_Vec3 delta);
void cr_Entity_translate_world_space(cr_Entity *e, cr_Vec3 delta);
void cr_Entity_rotate(cr_Entity *e, cr_Vec3 thetas);
void cr_Entity_rotate_world_space(cr_Entity *e, cr_Vec3 thetas);
cr_Matrix cr_Entity_get_world_space_transform(cr_Entity *e,
                                              cr_Matrix transform);
cr_Scene cr_Scene_create(cr_SceneSettings settings);
void cr_Scene_add_entity(cr_Scene *s, cr_Entity *e);
void cr_Scene_remove_entity(cr_Scene *s, cr_Entity *e);
void cr_Scene_rebuild_transform(cr_Scene *s);
int cr_Scene_init(cr_Scene *s);
int cr_Scene_update_settings(cr_Scene *s);
int cr_Scene_resize(cr_Scene *s, size_t new_width, size_t new_height);
void cr_Scene_dealloc(cr_Scene *s);
void cr_Scene_reset_buffers(cr_Scene *s);
void cr_Scene_render(cr_Scene *s, int num_threads);
bool cr_Entity_uses_texture(cr_Entity *e, cr_Texture *t);
bool cr_Scene_uses_texture(cr_Scene *s, cr_Texture *t);
typedef bool (*cr_Texture_draw_face_tp)(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_GOURAUD_FLOOR_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_GOURAUD_FLOOR_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_GOURAUD_CLOSEST_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_GOURAUD_CLOSEST_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_GOURAUD_LINEAR_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_GOURAUD_LINEAR_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_PHONG_FLOOR_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_PHONG_FLOOR_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_PHONG_CLOSEST_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_PHONG_CLOSEST_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_PHONG_LINEAR_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
bool _cr_Texture_draw_face_PHONG_LINEAR_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane);
#define _ERRNO_H 1
#define _BITS_ERRNO_H 1
#define _ASM_GENERIC_ERRNO_H
#define _ASM_GENERIC_ERRNO_BASE_H
#define EPERM 1
#define ENOENT 2
#define ESRCH 3
#define EINTR 4
#define EIO 5
#define ENXIO 6
#define E2BIG 7
#define ENOEXEC 8
#define EBADF 9
#define ECHILD 10
#define EAGAIN 11
#define ENOMEM 12
#define EACCES 13
#define EFAULT 14
#define ENOTBLK 15
#define EBUSY 16
#define EEXIST 17
#define EXDEV 18
#define ENODEV 19
#define ENOTDIR 20
#define EISDIR 21
#define EINVAL 22
#define ENFILE 23
#define EMFILE 24
#define ENOTTY 25
#define ETXTBSY 26
#define EFBIG 27
#define ENOSPC 28
#define ESPIPE 29
#define EROFS 30
#define EMLINK 31
#define EPIPE 32
#define EDOM 33
#define ERANGE 34
#define EDEADLK 35
#define ENAMETOOLONG 36
#define ENOLCK 37
#define ENOSYS 38
#define ENOTEMPTY 39
#define ELOOP 40
#define EWOULDBLOCK EAGAIN
#define ENOMSG 42
#define EIDRM 43
#define ECHRNG 44
#define EL2NSYNC 45
#define EL3HLT 46
#define EL3RST 47
#define ELNRNG 48
#define EUNATCH 49
#define ENOCSI 50
#define EL2HLT 51
#define EBADE 52
#define EBADR 53
#define EXFULL 54
#define ENOANO 55
#define EBADRQC 56
#define EBADSLT 57
#define EDEADLOCK EDEADLK
#define EBFONT 59
#define ENOSTR 60
#define ENODATA 61
#define ETIME 62
#define ENOSR 63
#define ENONET 64
#define ENOPKG 65
#define EREMOTE 66
#define ENOLINK 67
#define EADV 68
#define ESRMNT 69
#define ECOMM 70
#define EPROTO 71
#define EMULTIHOP 72
#define EDOTDOT 73
#define EBADMSG 74
#define EOVERFLOW 75
#define ENOTUNIQ 76
#define EBADFD 77
#define EREMCHG 78
#define ELIBACC 79
#define ELIBBAD 80
#define ELIBSCN 81
#define ELIBMAX 82
#define ELIBEXEC 83
#define EILSEQ 84
#define ERESTART 85
#define ESTRPIPE 86
#define EUSERS 87
#define ENOTSOCK 88
#define EDESTADDRREQ 89
#define EMSGSIZE 90
#define EPROTOTYPE 91
#define ENOPROTOOPT 92
#define EPROTONOSUPPORT 93
#define ESOCKTNOSUPPORT 94
#define EOPNOTSUPP 95
#define EPFNOSUPPORT 96
#define EAFNOSUPPORT 97
#define EADDRINUSE 98
#define EADDRNOTAVAIL 99
#define ENETDOWN 100
#define ENETUNREACH 101
#define ENETRESET 102
#define ECONNABORTED 103
#define ECONNRESET 104
#define ENOBUFS 105
#define EISCONN 106
#define ENOTCONN 107
#define ESHUTDOWN 108
#define ETOOMANYREFS 109
#define ETIMEDOUT 110
#define ECONNREFUSED 111
#define EHOSTDOWN 112
#define EHOSTUNREACH 113
#define EALREADY 114
#define EINPROGRESS 115
#define ESTALE 116
#define EUCLEAN 117
#define ENOTNAM 118
#define ENAVAIL 119
#define EISNAM 120
#define EREMOTEIO 121
#define EDQUOT 122
#define ENOMEDIUM 123
#define EMEDIUMTYPE 124
#define ECANCELED 125
#define ENOKEY 126
#define EKEYEXPIRED 127
#define EKEYREVOKED 128
#define EKEYREJECTED 129
#define EOWNERDEAD 130
#define ENOTRECOVERABLE 131
#define ERFKILL 132
#define EHWPOISON 133
#define ENOTSUP EOPNOTSUPP

extern int *__errno_location(void) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
#define errno (*__errno_location())

#define _STRING_H 1
#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#undef __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#undef __GLIBC_USE_LIB_EXT2
#define __GLIBC_USE_LIB_EXT2 0
#undef __GLIBC_USE_IEC_60559_BFP_EXT
#define __GLIBC_USE_IEC_60559_BFP_EXT 0
#undef __GLIBC_USE_IEC_60559_BFP_EXT_C23
#define __GLIBC_USE_IEC_60559_BFP_EXT_C23 1
#undef __GLIBC_USE_IEC_60559_EXT
#define __GLIBC_USE_IEC_60559_EXT 0
#undef __GLIBC_USE_IEC_60559_FUNCS_EXT
#define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
#undef __GLIBC_USE_IEC_60559_FUNCS_EXT_C23
#define __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 1
#undef __GLIBC_USE_IEC_60559_TYPES_EXT
#define __GLIBC_USE_IEC_60559_TYPES_EXT 0

#define __need_size_t
#define __need_NULL
#undef __need_ptrdiff_t
#undef __need_size_t
#undef __need_wchar_t
#undef NULL
#define NULL ((void *)0)
#undef __need_NULL
#undef offsetof
#define offsetof(TYPE, MEMBER) __builtin_offsetof(TYPE, MEMBER)
extern void *memcpy(void *__restrict __dest, const void *__restrict __src,
                    size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1, 2)));
extern void *memmove(void *__dest, const void *__src, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern void *memccpy(void *__restrict __dest, const void *__restrict __src,
                     int __c, size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1, 2)))
__attribute__((__access__(__write_only__, 1, 4)));
extern void *memset(void *__s, int __c, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)));
extern int memcmp(const void *__s1, const void *__s2, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern void *memchr(const void *__s, int __c, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1)));
extern char *strcpy(char *__restrict __dest, const char *__restrict __src)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern char *strncpy(char *__restrict __dest, const char *__restrict __src,
                     size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1, 2)));
extern char *strcat(char *__restrict __dest, const char *__restrict __src)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern char *strncat(char *__restrict __dest, const char *__restrict __src,
                     size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1, 2)));
extern int strcmp(const char *__s1, const char *__s2)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern int strncmp(const char *__s1, const char *__s2, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern int strcoll(const char *__s1, const char *__s2)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern size_t strxfrm(char *__restrict __dest, const char *__restrict __src,
                      size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(2)))
__attribute__((__access__(__write_only__, 1, 3)));
#define _BITS_TYPES_LOCALE_T_H 1
#define _BITS_TYPES___LOCALE_T_H 1
struct __locale_struct {
  struct __locale_data *__locales[13];
  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;
  const char *__names[13];
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2, 3)));
extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n,
                        locale_t __l) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(2, 4)))
__attribute__((__access__(__write_only__, 1, 3)));
extern char *strdup(const char *__s) __attribute__((__nothrow__, __leaf__))
__attribute__((__malloc__)) __attribute__((__nonnull__(1)));
extern char *strndup(const char *__string, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__malloc__))
    __attribute__((__nonnull__(1)));
extern char *strchr(const char *__s, int __c)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1)));
extern char *strrchr(const char *__s, int __c)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1)));
extern char *strchrnul(const char *__s, int __c)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1)));
extern size_t strcspn(const char *__s, const char *__reject)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern size_t strspn(const char *__s, const char *__accept)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern char *strpbrk(const char *__s, const char *__accept)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern char *strstr(const char *__haystack, const char *__needle)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern char *strtok(char *__restrict __s, const char *__restrict __delim)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2)));
extern char *__strtok_r(char *__restrict __s, const char *__restrict __delim,
                        char **__restrict __save_ptr)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2, 3)));
extern char *strtok_r(char *__restrict __s, const char *__restrict __delim,
                      char **__restrict __save_ptr)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2, 3)));
extern char *strcasestr(const char *__haystack, const char *__needle)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern void *memmem(const void *__haystack, size_t __haystacklen,
                    const void *__needle, size_t __needlelen)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 3)))
    __attribute__((__access__(__read_only__, 1, 2)))
    __attribute__((__access__(__read_only__, 3, 4)));
extern void *__mempcpy(void *__restrict __dest, const void *__restrict __src,
                       size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1, 2)));
extern void *mempcpy(void *__restrict __dest, const void *__restrict __src,
                     size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1, 2)));
extern size_t strlen(const char *__s) __attribute__((__nothrow__, __leaf__))
__attribute__((__pure__)) __attribute__((__nonnull__(1)));
extern size_t strnlen(const char *__string, size_t __maxlen)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1)));
extern char *strerror(int __errnum) __attribute__((__nothrow__, __leaf__));
extern int strerror_r(int __errnum, char *__buf,
                      size_t __buflen) __asm__(""
                                               "__xpg_strerror_r")
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2)))
    __attribute__((__access__(__write_only__, 2, 3)));
extern char *strerror_l(int __errnum, locale_t __l)
    __attribute__((__nothrow__, __leaf__));
#define _STRINGS_H 1
#define __need_size_t
#undef __need_ptrdiff_t
#undef __need_size_t
#undef __need_wchar_t
#undef NULL
#define NULL ((void *)0)
#undef __need_NULL
#undef offsetof
#define offsetof(TYPE, MEMBER) __builtin_offsetof(TYPE, MEMBER)

extern int bcmp(const void *__s1, const void *__s2, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern void bcopy(const void *__src, void *__dest, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern void bzero(void *__s, size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1)));
extern char *index(const char *__s, int __c)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1)));
extern char *rindex(const char *__s, int __c)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1)));
extern int ffs(int __i) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
extern int ffsl(long int __l) __attribute__((__nothrow__, __leaf__))
__attribute__((__const__));
__extension__ extern int ffsll(long long int __ll)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__const__));
extern int strcasecmp(const char *__s1, const char *__s2)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2)));
extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))
    __attribute__((__nonnull__(1, 2, 3)));
extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n,
                         locale_t __loc) __attribute__((__nothrow__, __leaf__))
__attribute__((__pure__)) __attribute__((__nonnull__(1, 2, 4)));

extern void explicit_bzero(void *__s, size_t __n)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1)))
    __attribute__((__access__(__write_only__, 1, 2)));
extern char *strsep(char **__restrict __stringp, const char *__restrict __delim)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern char *strsignal(int __sig) __attribute__((__nothrow__, __leaf__));
extern char *__stpcpy(char *__restrict __dest, const char *__restrict __src)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern char *stpcpy(char *__restrict __dest, const char *__restrict __src)
    __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));
extern char *__stpncpy(char *__restrict __dest, const char *__restrict __src,
                       size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1, 2)));
extern char *stpncpy(char *__restrict __dest, const char *__restrict __src,
                     size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1, 2)));
extern size_t strlcpy(char *__restrict __dest, const char *__restrict __src,
                      size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1, 2)))
__attribute__((__access__(__write_only__, 1, 3)));
extern size_t strlcat(char *__restrict __dest, const char *__restrict __src,
                      size_t __n) __attribute__((__nothrow__, __leaf__))
__attribute__((__nonnull__(1, 2)))
__attribute__((__access__(__read_write__, 1, 3)));

cr_Texture cr_Texture_alloc(int width, int height) {
  if (!(cr_crender_initted))
    do {
      fprintf(stderr,
              "%s:%d [%s]"
              ": crender not initted! use the macro cr_INIT_CRENDER()."
              "\n",
              "src/texture.c", 8,
              "Assertion `"
              "cr_crender_initted"
              "` failed");
      abort();
    } while (0);
  ;
  cr_Texture texture;
  texture.width = width;
  texture.height = height;
  texture.m = malloc(sizeof(cr_Vec3) * width * height);
  texture.valid = true;
  if (!texture.m) {
    perror("cr_Texture_alloc: malloc() failed");
  }
  return texture;
}
cr_Texture cr_Texture_create(int width, int height, cr_Vec3 color) {
  cr_Texture texture = cr_Texture_alloc(width, height);
  if (!texture.m)
    return texture;
  for (int i = 0; i < width * height; i++) {
    texture.m[i] = color;
  }
  return texture;
}
void cr_Texture_writePPM(cr_Texture texture, char *fn) {
  if (!texture.m) {
    return;
  }
  FILE *fp = fopen(fn, "wb");
  if (!fp) {
    perror("cr_Texture_writePPM: fopen() failed");
    return;
  }
  fprintf(fp, "P6\n%d %d\n255\n", texture.width, texture.height);
  for (int i = 0; i < texture.width * texture.height; i++) {
    cr_Vec3 color = texture.m[i];
    fputc(color.x, fp);
    fputc(color.y, fp);
    fputc(color.z, fp);
  }
  fclose(fp);
}
cr_Texture cr_Texture_readPPM(char *fn) {
  FILE *fp = fopen(fn, "rb");
  char mode[3];
  int width;
  int height;
  unsigned long lmaxn;
  if (!fp) {
    fprintf(stderr, "cr_Texture_readPPM: fopen(%s) failed: %s\n", fn,
            strerror((*__errno_location())));
    return (cr_Texture){0};
  }
  if (!fgets(mode, sizeof(mode), fp)) {
    fprintf(stderr, "cr_Texture_readPPM: format error: can't read mode\n");
    return (cr_Texture){0};
  }
  if (strcmp(mode, "P6")) {
    fprintf(stderr,
            "cr_Texture_readPPM: format error: mode %s is not supported\n",
            mode);
    return (cr_Texture){0};
  }
  if (fscanf(fp, "\n%d %d\n%lu\n", &width, &height, &lmaxn) != 3) {
    fprintf(stderr, "cr_Texture_readPPM: format error: can't read header\n");
    return (cr_Texture){0};
  }
  if (lmaxn != 255) {
    fprintf(stderr,
            "cr_Texture_readPPM: format error: can only read 24-bit colors\n");
    return (cr_Texture){0};
  }
  cr_Texture texture = cr_Texture_alloc(width, height);
  if (!texture.m) {
    perror("cr_Texture_readPPM: can't allocate");
    return (cr_Texture){0};
  }
  for (int i = 0; i < width * height; i++) {
    unsigned char rgb[3];
    fread(&rgb, 1, 3, fp);
    if (feof(fp)) {
      fprintf(stderr, "cr_Texture_readPPM: format error: EOF\n");
      cr_Texture_dealloc(&texture);
      return (cr_Texture){0};
    }
    texture.m[i] = cr_Vec3_create(rgb[0], rgb[1], rgb[2]);
  }
  return texture;
}
cr_Texture cr_Texture_readPAM(char *fn) {
  FILE *fp = fopen(fn, "rb");
  char mode[3];
  int width;
  int height;
  short depth;
  unsigned long lmaxn;
  if (!fp) {
    perror("cr_Texture_readPAM: fopen() failed");
    abort();
  }
  if (!fgets(mode, sizeof(mode), fp)) {
    perror("cr_Texture_readPAM: format error");
    abort();
  }
  if (strcmp(mode, "P7")) {
    (*__errno_location()) = 95;
    perror("cr_Texture_readPAM: format error");
    abort();
  }
  char *tupltype = malloc(32 * sizeof(char));
  if (fscanf(
          fp,
          "\nWIDTH %d\nHEIGHT %d\nDEPTH %hd\nMAXVAL %lu\nTUPLTYPE %s\nENDHDR\n",
          &width, &height, &depth, &lmaxn, tupltype) != 5) {
    free(tupltype);
    (*__errno_location()) = 22;
    perror("cr_Texture_readPAM: format error");
    abort();
  }
  if (strcmp(tupltype, "RGB_ALPHA")) {
    free(tupltype);
    (*__errno_location()) = 95;
    perror("cr_Texture_readPAM: can only read RGB_ALPHA pams");
    abort();
  }
  free(tupltype);
  if (depth != 4) {
    perror("cr_Texture_readPAM: expected depth 4");
    abort();
  }
  if (lmaxn != 255) {
    (*__errno_location()) = 95;
    perror("cr_Texture_readPAM: expected maxval 255");
    abort();
  }
  cr_Texture texture =
      cr_Texture_create(width, height, cr_Vec3_create(0, 0, 0));
  if (!texture.m) {
    abort();
  }
  for (int i = 0; i < height; i++) {
    unsigned char rgb[4];
    fread(&rgb, 1, 4, fp);
    if (feof(fp)) {
      cr_Texture_dealloc(&texture);
      perror("cr_Texture_readPAM: format error");
      abort();
    }
    texture.m[i] = cr_Vec3_create(rgb[0], rgb[1], rgb[2]);
  }
  return texture;
}
cr_Texture cr_Texture_read(char *fn) {
  if (strcmp(fn + strlen(fn) - 4, ".ppm") == 0) {
    return cr_Texture_readPPM(fn);
  } else if (strcmp(fn + strlen(fn) - 4, ".pam") == 0) {
    return cr_Texture_readPAM(fn);
  } else {
    (*__errno_location()) = 95;
    perror("cr_Texture_read: unknown file format");
    abort();
  }
}
static inline cr_Vec3 cr_Texture_getuv_CLOSEST(const cr_Texture *restrict t,
                                               cr_Vec3 uv) {
  int x = (int)((cr_clamp(uv.x, 0.0, 1.0)) * (t->width - 1) + .5f);
  int y = (int)((cr_clamp((1 - uv.y), 0.0, 1.0)) * (t->height - 1) + .5f);
  return t->m[y * t->width + x];
}
static inline cr_Vec3 cr_Texture_getuv_FLOOR(const cr_Texture *restrict t,
                                             cr_Vec3 uv) {
  int x = (int)((cr_clamp(uv.x, 0.0, 1.0)) * (t->width - 1));
  int y = (int)((cr_clamp((1 - uv.y), 0.0, 1.0)) * (t->height - 1));
  return t->m[y * t->width + x];
}
static inline cr_Vec3 cr_Texture_getuv_LINEAR(const cr_Texture *restrict t,
                                              cr_Vec3 uv) {
  size_t w = t->width, h = t->height;
  float u = cr_clamp(uv.x, 0.0, 1.0);
  float v = 1.0 - (cr_clamp(uv.y, 0.0, 1.0));
  float x = u * (w - 1);
  float y = v * (h - 1);
  int x0 = (int)x;
  int y0 = (int)y;
  int x1 = x0 + (x0 + 1 < w);
  int y1 = y0 + (y0 + 1 < h);
  float tx = x - x0;
  float ty = y - y0;
  const cr_Vec3 *restrict row0 = &t->m[y0 * w];
  const cr_Vec3 *restrict row1 = &t->m[y1 * w];
  cr_Vec3 c00 = row0[x0];
  cr_Vec3 c10 = row0[x1];
  cr_Vec3 c01 = row1[x0];
  cr_Vec3 c11 = row1[x1];
  float w00 = (1 - tx) * (1 - ty);
  float w10 = tx * (1 - ty);
  float w01 = (1 - tx) * ty;
  float w11 = tx * ty;
  return (cr_Vec3){c00.x * w00 + c10.x * w10 + c01.x * w01 + c11.x * w11,
                   c00.y * w00 + c10.y * w10 + c01.y * w01 + c11.y * w11,
                   c00.z * w00 + c10.z * w10 + c01.z * w01 + c11.z * w11};
}
static inline cr_Vec3 cr_Texture_getuv(const cr_Texture *t, cr_Vec3 uv,
                                       cr_SamplingMode sampling_mode) {
  switch (sampling_mode) {
  case FLOOR:
    return cr_Texture_getuv_FLOOR(t, uv);
  case CLOSEST:
    return cr_Texture_getuv_CLOSEST(t, uv);
  case LINEAR:
    return cr_Texture_getuv_LINEAR(t, uv);
  default:
    do {
      fprintf(stderr,
              "%s:%d [%s]"
              "Texture_getuv"
              "\n",
              "src/texture.c", 225, "Unreachable");
      abort();
    } while (0);
  }
}
static inline cr_Vec3 _interp_correct(cr_Vec3 v0, cr_Vec3 v1, cr_Vec3 v2,
                                      cr_Vec3 b, float w0, float w1, float w2) {
  float bxw = b.x * w0, byw = b.y * w1, bzw = b.z * w2;
  float iw = w0 * b.x + w1 * b.y + w2 * b.z;
  return (cr_Vec3){
      (v0.x * bxw + v1.x * byw + v2.x * bzw) / iw,
      (v0.y * bxw + v1.y * byw + v2.y * bzw) / iw,
      (v0.z * bxw + v1.z * byw + v2.z * bzw) / iw,
  };
}
float apow(float x, uint8_t n) {
  float p[8];
  p[0] = x;
  for (int i = 1; i < 8; i++)
    p[i] = p[i - 1] * p[i - 1];
  float r = 1.0;
  for (int i = 0; i < 8; i++)
    if (n & (1 << i))
      r *= p[i];
  return r;
}
void cr_Texture_dealloc_ref(cr_Texture *texture) {
  if (!texture->m)
    return;
  free(texture->m);
}
void cr_Texture_dealloc(cr_Texture *texture) {
  if (!texture || !texture->valid)
    return;
  free(texture->m);
}
cr_Linear_Texture cr_Texture_to_linear(cr_Texture texture) {
  cr_Linear_Texture t = malloc(texture.width * texture.height * sizeof(*t));
  for (int i = 0; i < texture.width * texture.height; i++) {
    t[(int)i] = cr_Vec3_pack_color(texture.m[i]);
  }
  return t;
}
#define _cr_Texture_shader_PHONG(SAMPLING_MODE, ...)                           \
  if (!specular_map) {                                                         \
    specpow = 2;                                                               \
  } else {                                                                     \
    specpow = cr_Texture_getuv_##SAMPLING_MODE(specular_map, uv).x;            \
  }                                                                            \
  spec = apow(fmax(d, 0.0), specpow);                                          \
  cr_num intensity = d + spec * .6;                                            \
  texture[(int)(tw * (th - y - 1) + x)] =                                      \
      cr_Vec3_phong(color, intensity, 0, 255);
#define _cr_Texture_shader_GOURAUD(...)                                        \
  (void)spec;                                                                  \
  (void)specpow;                                                               \
  (void)specular_map;                                                          \
  texture[(int)(tw * (th - y - 1) + x)] =                                      \
      cr_Vec3_pack_color(cr_Vec3_mul(color, fmax(d, 0.0)));
#define _cr_Texture_draw_face_IMPL(SHADING_MODE, SAMPLING_MODE,                \
                                   HAS_NORMAL_MAP)                             \
  _cr_Texture_draw_face_DECL(SHADING_MODE, SAMPLING_MODE, HAS_NORMAL_MAP) {    \
    (void)zbuffer_locks;                                                       \
    cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);           \
    cr_Vec3 ldir = cr_Vec3_normalized(l);                                      \
    bool has_vns = true;                                                       \
    cr_Triangle raw_tri, uvs, vns;                                             \
    if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {                        \
      return false;                                                            \
    }                                                                          \
    cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);   \
    if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||          \
        world_tri.v2.z > near_plane) {                                         \
      return false;                                                            \
    }                                                                          \
    cr_Vec3 n;                                                                 \
    if (!CR_CFG_NO_BFCULL) {                                                   \
      n = cr_Vec3_normalized(                                                  \
          cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),                   \
                        cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));                 \
      cr_num intensity = cr_Vec3_dot(n, ldir);                                 \
      if (intensity < -cr_EPSILON) {                                           \
        return false;                                                          \
      }                                                                        \
    }                                                                          \
    if (!cr_Face_gettri(face, obj, UV, &uvs)) {                                \
      return false;                                                            \
    }                                                                          \
    if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {             \
      n = cr_Vec3_normalized(                                                  \
          cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),                   \
                        cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));                 \
      has_vns = false;                                                         \
      vns = cr_Triangle_create(n, n, n);                                       \
    }                                                                          \
    cr_Vec3 ws;                                                                \
    cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);         \
    cr_num x0 = tri.v0.x, y0 = tri.v0.y;                                       \
    cr_num x1 = tri.v1.x, y1 = tri.v1.y;                                       \
    cr_num x2 = tri.v2.x, y2 = tri.v2.y;                                       \
    cr_num bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));   \
    cr_num tw = width;                                                         \
    cr_num th = height;                                                        \
    int minx = fmax(0, cr_fmin3(x0, x1, x2));                                  \
    int maxx = fmin(width, cr_fmax3(x0, x1, x2));                              \
    int miny = fmax(0, cr_fmin3(y0, y1, y2));                                  \
    int maxy = fmin(height, cr_fmax3(y0, y1, y2));                             \
    cr_num iw0 = 1.0f / ws.x;                                                  \
    cr_num iw1 = 1.0f / ws.y;                                                  \
    cr_num iw2 = 1.0f / ws.z;                                                  \
    if (maxx < 0 || maxy < 0 || minx > tw || miny > th)                        \
      return false;                                                            \
    cr_Vec3 bbase =                                                            \
        cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);        \
    cr_Vec3 deltax = cr_Vec3_sub(                                              \
        cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),    \
        bbase);                                                                \
    cr_Vec3 deltay = cr_Vec3_sub(                                              \
        cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),    \
        bbase);                                                                \
    for (int y = miny; y <= maxy; y++) {                                       \
      if (y < 0) {                                                             \
        cr_Vec3_ADD_INPLACE(bbase, deltay);                                    \
        continue;                                                              \
      }                                                                        \
      cr_Vec3 b = bbase;                                                       \
      for (int x = minx; x <= maxx; x++) {                                     \
        if (x < 0) {                                                           \
          cr_Vec3_ADD_INPLACE(b, deltax);                                      \
          continue;                                                            \
        }                                                                      \
        cr_NUM_INT_TYPE ibx, iby, ibz;                                         \
        cr_NUM_INT_CAST(b.x, ibx);                                             \
        cr_NUM_INT_CAST(b.y, iby);                                             \
        cr_NUM_INT_CAST(b.z, ibz);                                             \
        cr_NUM_INT_TYPE inside = ibx | iby | ibz;                              \
        if (inside < 0) {                                                      \
          cr_Vec3_ADD_INPLACE(b, deltax);                                      \
          continue;                                                            \
        }                                                                      \
        cr_num iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;                         \
        cr_num z = iz;                                                         \
        int zbuffix = x + y * tw;                                              \
        CR_IFOMPLOCK(omp_lock_t * lock);                                       \
        CR_IFOMPLOCK(lock = &zbuffer_locks[zbuffix]);                          \
        CR_IFOMPLOCK(omp_set_lock(lock));                                      \
        if (zbuffer[zbuffix] < z) {                                            \
          cr_num spec, specpow;                                                \
          cr_Vec3 normal;                                                      \
          zbuffer[zbuffix] = z;                                                \
          cr_Vec3 uv =                                                         \
              _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);       \
          cr_Vec3 color = cr_Texture_getuv_##SAMPLING_MODE(diffuse, uv);       \
          if (!HAS_NORMAL_MAP) {                                               \
            if (has_vns) {                                                     \
              normal = cr_Vec3_neg(                                            \
                  _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));  \
            } else {                                                           \
              normal = n;                                                      \
            }                                                                  \
          } else {                                                             \
            normal = (cr_Vec3_normal_from_color(                               \
                cr_Texture_getuv_##SAMPLING_MODE(normal_map, uv)));            \
          }                                                                    \
          cr_num d = cr_Vec3_dot(normal, ldir);                                \
          _cr_Texture_shader_##SHADING_MODE(SAMPLING_MODE);                    \
        }                                                                      \
        CR_IFOMPLOCK(omp_unset_lock(lock));                                    \
        cr_Vec3_ADD_INPLACE(b, deltax);                                        \
      }                                                                        \
      cr_Vec3_ADD_INPLACE(bbase, deltay);                                      \
    }                                                                          \
    return true;                                                               \
  }
bool _cr_Texture_draw_face_GOURAUD_FLOOR_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_FLOOR(diffuse, uv);
        if (!0) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_FLOOR(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        (void)spec;
        (void)specpow;
        (void)specular_map;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_pack_color(cr_Vec3_mul(color, fmax(d, 0.0)));
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
bool _cr_Texture_draw_face_GOURAUD_FLOOR_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_FLOOR(diffuse, uv);
        if (!1) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_FLOOR(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        (void)spec;
        (void)specpow;
        (void)specular_map;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_pack_color(cr_Vec3_mul(color, fmax(d, 0.0)));
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
bool _cr_Texture_draw_face_GOURAUD_CLOSEST_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_CLOSEST(diffuse, uv);
        if (!0) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_CLOSEST(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        (void)spec;
        (void)specpow;
        (void)specular_map;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_pack_color(cr_Vec3_mul(color, fmax(d, 0.0)));
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
bool _cr_Texture_draw_face_GOURAUD_CLOSEST_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_CLOSEST(diffuse, uv);
        if (!1) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_CLOSEST(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        (void)spec;
        (void)specpow;
        (void)specular_map;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_pack_color(cr_Vec3_mul(color, fmax(d, 0.0)));
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
bool _cr_Texture_draw_face_GOURAUD_LINEAR_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_LINEAR(diffuse, uv);
        if (!0) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_LINEAR(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        (void)spec;
        (void)specpow;
        (void)specular_map;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_pack_color(cr_Vec3_mul(color, fmax(d, 0.0)));
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
bool _cr_Texture_draw_face_GOURAUD_LINEAR_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_LINEAR(diffuse, uv);
        if (!1) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_LINEAR(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        (void)spec;
        (void)specpow;
        (void)specular_map;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_pack_color(cr_Vec3_mul(color, fmax(d, 0.0)));
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
bool _cr_Texture_draw_face_PHONG_FLOOR_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_FLOOR(diffuse, uv);
        if (!0) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_FLOOR(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        if (!specular_map) {
          specpow = 2;
        } else {
          specpow = cr_Texture_getuv_FLOOR(specular_map, uv).x;
        }
        spec = apow(fmax(d, 0.0), specpow);
        float intensity = d + spec * .6;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_phong(color, intensity, 0, 255);
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
bool _cr_Texture_draw_face_PHONG_FLOOR_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_FLOOR(diffuse, uv);
        if (!1) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_FLOOR(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        if (!specular_map) {
          specpow = 2;
        } else {
          specpow = cr_Texture_getuv_FLOOR(specular_map, uv).x;
        }
        spec = apow(fmax(d, 0.0), specpow);
        float intensity = d + spec * .6;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_phong(color, intensity, 0, 255);
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
bool _cr_Texture_draw_face_PHONG_CLOSEST_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_CLOSEST(diffuse, uv);
        if (!0) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_CLOSEST(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        if (!specular_map) {
          specpow = 2;
        } else {
          specpow = cr_Texture_getuv_CLOSEST(specular_map, uv).x;
        }
        spec = apow(fmax(d, 0.0), specpow);
        float intensity = d + spec * .6;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_phong(color, intensity, 0, 255);
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
bool _cr_Texture_draw_face_PHONG_CLOSEST_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_CLOSEST(diffuse, uv);
        if (!1) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_CLOSEST(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        if (!specular_map) {
          specpow = 2;
        } else {
          specpow = cr_Texture_getuv_CLOSEST(specular_map, uv).x;
        }
        spec = apow(fmax(d, 0.0), specpow);
        float intensity = d + spec * .6;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_phong(color, intensity, 0, 255);
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
bool _cr_Texture_draw_face_PHONG_LINEAR_0(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_LINEAR(diffuse, uv);
        if (!0) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_LINEAR(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        if (!specular_map) {
          specpow = 2;
        } else {
          specpow = cr_Texture_getuv_LINEAR(specular_map, uv).x;
        }
        spec = apow(fmax(d, 0.0), specpow);
        float intensity = d + spec * .6;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_phong(color, intensity, 0, 255);
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
bool _cr_Texture_draw_face_PHONG_LINEAR_1(
    cr_Linear_Texture texture, int width, int height, cr_Face *face,
    cr_Object *obj, cr_Texture *diffuse, cr_Texture *normal_map,
    cr_Texture *specular_map, float *zbuffer, omp_lock_t *zbuffer_locks,
    cr_Vec3 light_dir, cr_Matrix transform, cr_Matrix world_transform,
    cr_Matrix inverse_transform, float near_plane) {
  (void)zbuffer_locks;
  cr_Vec3 l = cr_Vec3_transform_dir(light_dir, inverse_transform);
  cr_Vec3 ldir = cr_Vec3_normalized(l);
  bool has_vns = true;
  cr_Triangle raw_tri, uvs, vns;
  if (!cr_Face_gettri(face, obj, VERTEX, &raw_tri)) {
    return false;
  }
  cr_Triangle world_tri = cr_Triangle_transform(raw_tri, world_transform);
  if (world_tri.v0.z > near_plane || world_tri.v1.z > near_plane ||
      world_tri.v2.z > near_plane) {
    return false;
  }
  cr_Vec3 n;
  if (!1) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    float intensity = cr_Vec3_dot(n, ldir);
    if (intensity < -1e-2) {
      return false;
    }
  }
  if (!cr_Face_gettri(face, obj, UV, &uvs)) {
    return false;
  }
  if (!cr_Face_gettri(face, obj, NORMAL, &vns) && !normal_map) {
    n = cr_Vec3_normalized(cr_Vec3_cross(cr_Vec3_sub(raw_tri.v2, raw_tri.v0),
                                         cr_Vec3_sub(raw_tri.v1, raw_tri.v0)));
    has_vns = false;
    vns = cr_Triangle_create(n, n, n);
  }
  cr_Vec3 ws;
  cr_Triangle tri = cr_Triangle_transform4(raw_tri, transform, &ws);
  float x0 = tri.v0.x, y0 = tri.v0.y;
  float x1 = tri.v1.x, y1 = tri.v1.y;
  float x2 = tri.v2.x, y2 = tri.v2.y;
  float bary_denom = 1 / ((x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0));
  float tw = width;
  float th = height;
  int minx = fmax(0, cr_fmin3(x0, x1, x2));
  int maxx = fmin(width, cr_fmax3(x0, x1, x2));
  int miny = fmax(0, cr_fmin3(y0, y1, y2));
  int maxy = fmin(height, cr_fmax3(y0, y1, y2));
  float iw0 = 1.0f / ws.x;
  float iw1 = 1.0f / ws.y;
  float iw2 = 1.0f / ws.z;
  if (maxx < 0 || maxy < 0 || minx > tw || miny > th)
    return false;
  cr_Vec3 bbase =
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny, bary_denom);
  cr_Vec3 deltax = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx + 1, miny, bary_denom),
      bbase);
  cr_Vec3 deltay = cr_Vec3_sub(
      cr_barycentric(tri.v0, tri.v1, tri.v2, minx, miny + 1, bary_denom),
      bbase);
  for (int y = miny; y <= maxy; y++) {
    if (y < 0) {
      bbase.x += deltay.x;
      bbase.y += deltay.y;
      bbase.z += deltay.z;
      continue;
    }
    cr_Vec3 b = bbase;
    for (int x = minx; x <= maxx; x++) {
      if (x < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      int32_t ibx, iby, ibz;
      memcpy(&ibx, &b.x, sizeof(int32_t));
      memcpy(&iby, &b.y, sizeof(int32_t));
      memcpy(&ibz, &b.z, sizeof(int32_t));
      int32_t inside = ibx | iby | ibz;
      if (inside < 0) {
        b.x += deltax.x;
        b.y += deltax.y;
        b.z += deltax.z;
        continue;
      }
      float iz = iw0 * b.x + iw1 * b.y + iw2 * b.z;
      float z = iz;
      int zbuffix = x + y * tw;
      omp_lock_t *lock;
      lock = &zbuffer_locks[zbuffix];
      omp_set_lock(lock);
      if (zbuffer[zbuffix] < z) {
        float spec, specpow;
        cr_Vec3 normal;
        zbuffer[zbuffix] = z;
        cr_Vec3 uv = _interp_correct(uvs.v0, uvs.v1, uvs.v2, b, iw0, iw1, iw2);
        cr_Vec3 color = cr_Texture_getuv_LINEAR(diffuse, uv);
        if (!1) {
          if (has_vns) {
            normal = cr_Vec3_neg(
                _interp_correct(vns.v0, vns.v1, vns.v2, b, iw0, iw1, iw2));
          } else {
            normal = n;
          }
        } else {
          normal = (cr_Vec3_normal_from_color(
              cr_Texture_getuv_LINEAR(normal_map, uv)));
        }
        float d = cr_Vec3_dot(normal, ldir);
        if (!specular_map) {
          specpow = 2;
        } else {
          specpow = cr_Texture_getuv_LINEAR(specular_map, uv).x;
        }
        spec = apow(fmax(d, 0.0), specpow);
        float intensity = d + spec * .6;
        texture[(int)(tw * (th - y - 1) + x)] =
            cr_Vec3_phong(color, intensity, 0, 255);
        ;
      }
      omp_unset_lock(lock);
      b.x += deltax.x;
      b.y += deltax.y;
      b.z += deltax.z;
    }
    bbase.x += deltay.x;
    bbase.y += deltay.y;
    bbase.z += deltay.z;
  }
  return true;
}
